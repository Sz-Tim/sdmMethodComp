---
title: "Exploration"
author: "Tim Szewczyk"
date: "2/16/2018"
output: html_document
---

```{r setup, include=F}
knitr::opts_chunk$set(echo = T)
pkgs <- c("fields", "sevcheck", "gbPopMod", "IPMpack", "tidyverse", "magrittr")
suppressMessages(invisible(lapply(pkgs, library, character.only=T)))
theme_set(theme_bw())
source("code/fn_IPM.R"); source("code/fn_aux.R")
lc.df <- read_csv("data/landcover_5km.csv") %>% 
  filter(!is.na(bio1_mean)) %>%
  mutate(x=as.integer(factor(.$left)),
         y=as.integer(factor(.$top,
                             levels=rev(levels(factor(.$top))))),
         x_y=paste(x, y, sep="_"))
```

# Exploration of options for the simulation component

## Species description: Life history, characteristics, relevant attributes
The simulated species is fully described here. The object `sp_i` is a list containing elements for the global parameters, relationships with environmental variables, and demographic matrices that are applicable or potentially applicable for that modeling strategy. Parameters are abbreviated with the associated kernel component (e.g., `s_*` for survival, `g_*` for growth, etc) and the type of covariate (`*_z` for size, `*_x` for environmental covariates).
```{r sp_i}
mean_abund <- 200
regPlots <- F
ipmPlots <- F
z.rng <- c(1, 12)
n <- 50  # ncells in IPM matrix
cells <- 1:n_distinct(lc.df$CellID)
n.cell <- length(cells)
n_i <- rpois(n.cell, mean_abund)
sp_i <- list(p=list(s_z=c(-1.75, .75), # b1 + b2*z
                    s_x=c(1, -.1, -.5, -.1, .05, -2, -.4), # b1*x1 + ...
                    g_z=c(.2, 2, -0.1), # b1 + b2*z + b3*z^2
                    g_x=c(1, -.1, 1.5, -.1, .1, -2), #b1*x1 + ...
                    g_sig=1, # growth ~ N(E, g_sig)
                    fl_z=c(-1.5, .1, .1), # b1 + b2*z + b3*z^2 + b4*z^3
                    fl_x=c(1, -.01, -1, -.01, 0, .2), # b1*x1 + ...
                    seed_z=c(2, 0.5, -.03), # b1 + b2*z + b2*z^2
                    seed_x=c(1, -.1, 1, -.1, .2), # b1*x1 + ...
                    rcr_z=c(1.5, 0.4), # N(mean=rcrt1, sd=rcrt2)
                    p_est=0.02, # p(establishment)
                    rcr_SB=0.2, # p(recruit from seedbank)
                    rcr_dir=0.6, # p(recruit directly)
                    s_SB=0.1, # p(survive in seedbank additional year)
                    sdd_max=3, # max SDD distance in cells
                    sdd_rate=1.5 # SDD dispersal rate
                    ))
sp_i$p$p_emig <- pexp(0.5, sp_i$p$sdd_rate, lower.tail=F) # p(seed emigrates)
```

## Landscape
The landscape characteristics are aggregated here. It is a gridded landscape with climate and LULC data.
```{r landscape}
env.rct <- as.tibble(expand.grid(x=1:max(lc.df$x),
                                 y=1:max(lc.df$y))) %>%
  mutate(x_y=paste(x, y, sep="_")) %>%
  mutate(temp=c(scale(lc.df$bio1_mean))[match(.$x_y, lc.df$x_y)],
         temp2=temp^2,
         prec=c(scale(lc.df$bio12_mean))[match(.$x_y, lc.df$x_y)],
         prec2=prec^2,
         pOpn=lc.df$nlcd1_mean[match(.$x_y, lc.df$x_y)],
         pOth=lc.df$nlcd2_mean[match(.$x_y, lc.df$x_y)],
         pDec=lc.df$nlcd3_mean[match(.$x_y, lc.df$x_y)],
         pEvg=lc.df$nlcd4_mean[match(.$x_y, lc.df$x_y)],
         pMxd=lc.df$nlcd5_mean[match(.$x_y, lc.df$x_y)],
         inbd=!is.na(match(.$x_y, lc.df$x_y)),
         id=row_number(), 
         id.inbd=min_rank(na_if(inbd*id, 0)),
         lat=lc.df$top[match(.$x_y, lc.df$x_y)],
         lon=lc.df$left[match(.$x_y, lc.df$x_y)])
env.rct[is.na(env.rct)] <- 0
sdd.pr <- sdd_set_probs(ncell=n.cell, lc.df=env.rct, lc.col=8:12,
                        g.p=list(sdd.max=sp_i$p$sdd_max, 
                                 sdd.rate=sp_i$p$sdd_rate, 
                                 bird.hab=rep(1,5)))
env.df <- filter(env.rct, inbd) %>% select(4:12, 1:3, 13:17) %>%
  mutate(pOpn=c(scale(pOpn)), pOth=c(scale(pOth)), pDec=c(scale(pDec)),
         pEvg=c(scale(pEvg)), pMxd=c(scale(pMxd)))
rm(env.rct)
# sdd.pr[,,2,] has indexes based on env.df$id -- NOT env.df$id.inbd
# ggplot(env.df, aes(x=lon, y=lat, fill=id %in% sdd.pr[,,2,760])) + geom_tile()
```

---

## Simulation: IPM framework
```{r S}
########
## set up
########
# set up storage & IPM matrix objects
p <- sp_i$p
setup_IPM_matrix(n, z.rng, buffer=0.25, discrete=1)
IPMs <- Ps <- Fs <- array(0, dim=c(n+1, n+1, n.cell))
d <- vector("list", length=n.cell)
B <- rpois(n.cell, n_i)
B_1 <- nSd <- D <- rep(NA, n.cell)
sdd <- array(0, dim=dim(sdd.pr) + c(0,0,1,0)) # add layer for nEmig
sdd[,,1:2,] <- sdd.pr

# set up environmental covariates
n_sz <- length(p$s_z); n_sx <- length(p$s_x)
n_gz <- length(p$g_z); n_gx <- length(p$g_x)
n_flz <- length(p$fl_z); n_flx <- length(p$fl_x)
n_seedz <- length(p$seed_z); n_seedx <- length(p$seed_x)
X_s <- as.matrix(env.df[,1:n_sx])
X_g <- as.matrix(env.df[,1:n_gx])
X_fl <- as.matrix(env.df[,1:n_flx])
X_seed <- as.matrix(env.df[,1:n_seedx])


########
## loop through cells
########
for(i in 1:n.cell) {
  d[[i]] <- data.frame(size=runif(n=n_i[i], min=z.rng[1], max=z.rng[2]))
  size.mx <- cbind(1, d[[i]]$size, d[[i]]$size^2, d[[i]]$size^3)
  
  #---- Truth: use assigned slopes to fill IPM matrix
  ### growth and survival
  G.mx <- h*outer(y, y, calc_grow, p=p, n_gz=n_gz, X.g=X_g[i,])
  S.v <- calc_surv(y, p=p, n_sz=n_sz, X.s=X_s[i,])
  ### Fix eviction of individuals below/above size limits
  for(k in 1:(n/2)) G.mx[1,k] <- G.mx[1,k] + 1 - sum(G.mx[,k])
  for(k in (n/2+1):n) G.mx[n,k] <- G.mx[n,k] + 1 - sum(G.mx[,k])
  ### fill P and F matrices
  for(k in z.i) Ps[k,z.i,i] <- G.mx[k-1,]*S.v
  Ps[1,1,i] <- calc_staySB(p)
  Fs[z.i,z.i,i] <- h*outer(y, y, calc_rcrDir, p=p, n_seedz=n_seedz,
                             n_flz=n_flz, X.seed=X_seed[i,], X.fl=X_fl[i,])
  Fs[1,z.i,i] <- calc_DirSB(y, p=p, n_seedz=n_seedz, n_flz=n_flz, 
                            X.seed=X_seed[i,], X.fl=X_fl[i,])
  Fs[z.i,1,i] <- calc_rcrSB(y, p)
  
  #---- generate data
  ## survival
  E_surv <- antilogit(size.mx[,1:n_sz] %*% p$s_z + c(X_s[i,] %*% p$s_x))
  d[[i]]$surv <- rbinom(n_i[i], 1, E_surv)
  ## growth
  E_grow <- size.mx[,1:n_gz] %*% p$g_z + c(X_g[i,] %*% p$g_x)
  d[[i]]$sizeNext <- rnorm(n_i[i], E_grow, p$g_sig)
  d[[i]]$sizeNext <- ifelse(d[[i]]$surv, d[[i]]$sizeNext, NA)
  ## flowering 
  E_fl <- antilogit(size.mx[,1:n_flz] %*% p$fl_z + c(X_fl[i,] %*% p$fl_x))
  d[[i]]$fl <- rbinom(n_i[i], 1, E_fl)
  ## seed production
  E_seed <- d[[i]]$fl * 
    exp(size.mx[,1:n_seedz] %*% p$seed_z + c(X_seed[i,] %*% p$seed_x))
  d[[i]]$seed <- rpois(n_i[i], E_seed)
  # d[[i]]$fl <- ifelse(d[[i]]$surv, d[[i]]$fl, NA)
  d[[i]]$seed <- ifelse(d[[i]]$fl==1, d[[i]]$seed, NA)
  nSd[i] <- sum(d[[i]]$seed, na.rm=T)
  ## seed bank: native
  B_1[i] <- B[i] * p$s_SB * (1 - p$rcr_SB) + 
    nSd[i] * (1 - p$p_emig) * (1 - p$rcr_dir) * p$s_SB
  ## recruits: native
  rcr.n <- max(ceiling(nSd[i] * (1 - p$p_emig) * p$rcr_dir * p$p_est +
                   B[i] * p$rcr_SB * p$p_est), 2) # â‰¥ 2 for IPMpack sd(rcr_z')
  rcr.i <- (1:rcr.n) + n_i[i]
  d[[i]][rcr.i,] <- NA
  d[[i]]$sizeNext[rcr.i] <- rnorm(rcr.n, p$rcr_z[1], p$rcr_z[2])
  ## emigrants
  sdd[,,3,i] <- nSd[i] * p$p_emig * sdd[,,1,i]
}
for(i in 1:n.cell) {
  sdd.i <- env.df$id[i] # full rectangle grid id for SDD indexes
  
  #---- Truth: add immigrants
  sdd.j <- which(sdd[,,2,]==sdd.i, arr.ind=TRUE)[,3]
  p.ij <- sdd[,,1,sdd.j][sdd[,,2,sdd.j]==sdd.i]
  imm.rcr <- map2(sdd.j, p.ij, 
                     ~h*outer(y, y, calc_rcrImm, p=p, .y, n_seedz=n_seedz,
                              n_flz=n_flz, X.seed=X_seed[.x,], X.fl=X_fl[.x,]))
  Fs[z.i,z.i,i] <- Fs[z.i,z.i,i] + Reduce(`+`, imm.rcr)
  imm.sb <- map2(sdd.j, p.ij,
                     ~calc_ImmSB(y, p=p, .y, n_seedz=n_seedz, n_flz=n_flz,
                                 X.seed=X_seed[.x,], X.fl=X_fl[.x,]))
  Fs[1,z.i,i] <- Fs[1,z.i,i] + 
    Reduce(`+`, imm.sb)
  
  #---- generate data: add immigrants
  # total immigrants
  D[i] <- sum(sdd[,,3,][sdd[,,2,]==sdd.i])
  # seed bank: immigrants
  B_1[i] <- B_1[i] + D[i] * (1 - p$rcr_dir) * p$s_SB
  # recruits: immigrants
  rcr.imm <- max(ceiling(D[i] * p$rcr_dir * p$p_est), 2)
  rcr.i <- (1:rcr.imm) + nrow(d[[i]])
  d[[i]][rcr.i,] <- NA
  d[[i]]$sizeNext[rcr.i] <- rnorm(rcr.imm, p$rcr_z[1], p$rcr_z[2])
}
IPMs <- Ps + Fs
lam.df <- env.df
lam.df$lambda <- apply(IPMs, 3, function(x) Re(eigen(x)$values[1]))
lam.df %<>% add_column(nSd=nSd, B0=B, B1=B_1, D=D)

########
## plots
########
ggplot(lam.df, aes(x=lon, y=lat, fill=log(lambda))) + geom_tile() +
  scale_fill_gradient2(low="darkblue", mid="white", high="darkred", midpoint=0)
ggplot(lam.df, aes(x=lon, y=lat, fill=lambda>1)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=nSd)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=D)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=B1>B0)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=nSd*p$p_emig > D)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=nSd*(1-p$p_emig) > D)) + geom_tile()
ggplot(lam.df, aes(x=lon, y=lat, fill=nSd*(1-p$p_emig) < D & lambda < 1)) +
  geom_tile()
par(mfrow=c(2,2))
plot(log(lambda) ~ temp, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambda) ~ prec, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambda) ~ pOth, data=lam.df); abline(h=0, col="red", lty=2)
plot(density(log(lam.df$lambda))); abline(v=0, col="red", lty=2)

if(regPlots) {
  par(mfrow=c(3,2), mar=c(4,4,2,1))
  xx <- tibble(size=seq(lo, hi, length.out=100), size2=size^2, size3=size^3)
  mx <- cbind(1, as.matrix(xx))
  xxx <- seq(0, hi*.5, length.out=100)
  for(i in 1:20) {
    z.t <- d[[i]][!is.na(d[[i]]$size),]; main.i <- paste("Cell", i)
    w1 <- Re(eigen(IPMs[,,i])$vectors[,1])[-1]; stable.dist1 <- w1/sum(w1)
    rcrt.z <- d[[i]]$sizeNext[is.na(d[[i]]$size) & !is.na(d[[i]]$sizeNext)]
    plot(surv~size, data=z.t, ylim=c(0,1), pch=20, col=rgb(0,0,0,0.2),
         main=paste("Surv:", main.i), xlab="Size (t)", ylab="P(surv to t+1)")
      lines(mx[,2], antilogit(mx[,1:n_sz]%*%p$s_z + c(X_s[i,]%*%p$s_x)), col=2)
    plot(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2), 
         main=paste("Growth:", main.i), xlab="Size (t)", ylab="Size (t+1)")
      lines(mx[,2], mx[,1:n_gz]%*%p$g_z + c(X_g[i,]%*%p$g_x), col=2)
      abline(a=0, b=1, lty=2)
    plot(fl~size, data=z.t, pch=20, ylim=c(0,1), col=rgb(0,0,0,0.2),
         main=paste("P(Flower):", main.i), xlab="Size (t)", ylab="P(flower)")
      lines(mx[,2], antilogit(mx[,1:n_flz]%*%p$fl_z + c(X_fl[i,]%*%p$fl_x)),
            col=2)
    plot(seed~size, data=z.t, pch=23-z.t$fl*3, col=rgb(0,0,0,0.2), 
         main=paste("nSeeds:", main.i), xlab="Size (t)", ylab="Number of seeds")
      lines(mx[,2], exp(mx[,1:n_seedz]%*%p$seed_z + c(X_seed[i,]%*%p$seed_x)),
            col=2)
    plot(y, stable.dist1, ylab="", type="l", col=2, 
         main=paste("Stable size distribution:", main.i), xlab="Size (t)")
    hist(d[[i]]$sizeNext[is.na(d[[i]]$size)], col="grey", freq=F, 
         main=paste("Recruit sizes:", main.i), xlab="Recruit size (t+1)")
      lines(xxx, dnorm(xxx, p$rcr_z[1], p$rcr_z[2]), col="red", lwd=2)
  }
}
if(ipmPlots) {
  par(mfrow=c(2,2), mar=c(4,4,2,1))
  x <- c(0, y)
  for(i in 1:n.cell) {
    z.t <- d[[i]][!is.na(d[[i]]$size),]; main.i <- paste("Cell", i)
    z.t$y <- y[findInterval(z.t$size, y, all.inside=T)]
    totSeeds <- group_by(z.t, y) %>% summarise(seed=sum(seed, na.rm=T))
    image.plot(x, x, t(Ps[,,i]), main=paste("P matrix:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
      points(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,1/(n_i[i]^.25)))
      abline(a=0, b=1, col="white", lty=2)
    image.plot(x, x, t(Fs[,,i]), main=paste("F matrix:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
      points(totSeeds$y, totSeeds$seed/max(totSeeds$seed)*hi*.9)
    image.plot(x, x, t(sens(IPMs[,,i])), main=paste("Sensitivity:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
    image.plot(x, x, t(elas(IPMs[,,i])), main=paste("Elasticity:", main.i),
               xlab="Size (t)", ylab="Size (t+1)")
  }
}
```

----

## Observed datasets
The simulated species *S* is sampled appropriately in order to fit each SDM model. The observed datasets,*O*, may be random or intentionally biased to mimic common issues with empirical data.
### Correlative: MaxEnt
```{r O_Mx}

```
### Mechanistic: CA
```{r O_CA}

```
### Mechanistic: IPM
```{r O_IPM}

```

---

## Fitting the models
Each observed dataset *O* is used to predict the distribution of species *S*. The predicted distribution *P* is compared to the known truth *S* to assess the predictive accuracy of each modeling approach, given any limitations, uncertainty, or bias imposed in *O*. 
### Correlative: MaxEnt
```{r P_Mx}

```
### Mechanistic: CA
```{r P_CA}

```
### Mechanistic: IPM
```{r P_IPM}
for(i in 1:ncell) {
  # ## IPMpack: estimate slopes from d[[i]]
  # ### set up seedbank transitions
  d[[i]]$stage <- d[[i]]$stageNext <- "continuous"
  d[[i]]$stage[is.na(d[[i]]$size)] <- NA
  d[[i]]$stageNext[d[[i]]$surv==0] <- "dead"
  d[[i]]$number <- 1
  seedbank <- data.frame(size=NA, surv=1, sizeNext=NA,
                         fl=NA, seed=NA,
                         stage=c("seedbank", "seedbank", "continuous"),
                         stageNext=c("seedbank", "continuous", "seedbank"),
                         number=c(p$s_SB * (1 - p$rcr_SB), 
                                  p$rcr_SB * p$p_est, 
                                  (1 - p$rcr_dir) * p$s_SB))
  d[[i]] <- rbind(d[[i]], seedbank)
  d[[i]]$stage <- as.factor(d[[i]]$stage)
  d[[i]]$stageNext <- as.factor(d[[i]]$stageNext)
  ### construct kernels
  so <- makeSurvObj(d[[i]], surv ~ size)
  go <- makeGrowthObj(d[[i]], sizeNext ~ size + size2)
  fo <- makeFecObj(d[[i]],
                   Formula=c(fl~size+size2, seed~size+size2),
                   Family=c("binomial", "poisson"),
                   Transform=c("none", "none"),
                   meanOffspringSize=mean(
                     d[[i]]$sizeNext[is.na(d[[i]]$size) &
                                       !is.na(d[[i]]$sizeNext)]),
                   sdOffspringSize=sd(
                     d[[i]]$sizeNext[is.na(d[[i]]$size) &
                                       !is.na(d[[i]]$sizeNext)]),
                   fecConstants=data.frame(seedlingEstablishmentRate=p$p_est),
                   offspringSplitter=data.frame(seedbank=(1-p$rcr_dir),
                                                continuous=p$rcr_dir)
                   )
  F.mx2 <- makeIPMFmatrix(fecObj=fo, minSize=lo, maxSize=hi,
                          correction="constant")
  D.mx2 <- makeDiscreteTrans(d[[i]], 
                             continuousToDiscreteExplanatoryVariables=1)
  dummy <- as.matrix(fo@offspringRel$coefficients[1], list(1, "seedbank"))
  D.mx2@meanToCont <- as.matrix(dummy, dimnames=c(1, "seedbank"))
  dummy <- as.matrix(fo@sdOffspringSize, dimnames=list(1, "seedbank"))
  D.mx2@sdToCont <- as.matrix(dummy, dimnames=c(1, "seedbank"))
  D.mx2@discreteTrans[1,1] <- p$s_SB * (1 - p$rcr_SB)
  D.mx2@discreteTrans[3,1] <- 1 - sum(D.mx2@discreteTrans[1:2,1])
  P.mx2 <- makeIPMPmatrix(growObj=go, survObj=so, discreteTrans=D.mx2,
                            minSize=lo, maxSize=hi, correction="constant")
  IPM2 <- P.mx2 + F.mx2
  lambdas2[i] <- Re(eigen(IPM2)$values[1])
  
  if(regPlots) {
    par(mfrow=c(3,2), mar=c(4,4,2,1))
    xx <- tibble(size=seq(lo, hi, length.out=100), size2=size^2, size3=size^3)
    plot(surv~size, data=d[[i]], ylim=c(0,1), pch=20, col=rgb(0,0,0,0.2),
         main=paste("Surv:", main.i), xlab="Size (t)", ylab="P(surv to t+1)")
      points(z.t$size, E_surv, cex=0.2, col="red")
      # lines(xx$size, predict(so@fit, xx, type="response"), col="blue")
    plot(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2), 
         main=paste("Growth:", main.i), xlab="Size (t)", ylab="Size (t+1)")
      points(z.t$size, E_grow, cex=0.2, col="red")
      # lines(xx$size, predict(go@fit, xx, type="response"), col="blue")
      abline(a=0, b=1, lty=2)
    plot(fl~size, data=z.t, pch=20, ylim=c(0,1), col=rgb(0,0,0,0.2),
         main=paste("P(Flower):", main.i), xlab="Size (t)", ylab="P(flower)")
      points(z.t$size, E_fl, cex=0.2, col="red")
      # lines(xx$size, predict(fo@fitFec[[1]], xx, type="response"), col="blue")
    plot(seed~size, data=z.t, pch=23-z.t$fl*3, col=rgb(0,0,0,0.2), 
         main=paste("nSeeds:", main.i), xlab="Size (t)", ylab="Number of seeds")
      points(z.t$size, E_seed, cex=0.2, col="red")
      # lines(xx$size, predict(fo@fitFec[[2]], xx, type="response"), col="blue")
    w1 <- Re(eigen(IPMs[,,i])$vectors[,1])[-1]; stable.dist1 <- w1/sum(w1)
    # w2 <- Re(eigen(IPM2)$vectors[,1])[-1]; stable.dist2 <- w2/sum(w2)
    yl <- range(stable.dist1)#range(c(stable.dist1, stable.dist2))
    plot(y, stable.dist1, ylab="", type="l", lwd=2, col="red", ylim=yl,
         main=paste("Stable size distribution:", main.i), xlab="Size (t)")
    # lines(y, stable.dist2, col="blue")
    hist(d[[i]]$sizeNext[rcrt.i], main=paste("Recruit sizes:", main.i), 
         xlab="Recruit size (t+1)", col="grey", freq=F)
      xxx <- seq(0, hi*.5, length.out=100)
      rcrt.z <- d[[i]]$sizeNext[is.na(d[[i]]$size) & !is.na(d[[i]]$sizeNext)]
      lines(xxx, dnorm(xxx, p$rcr_z[1], p$rcr_z[2]), col="red", lwd=2)
      # lines(xxx, dnorm(xxx, mean(rcrt.z), sd(rcrt.z)), col="blue")
  }
}


```



