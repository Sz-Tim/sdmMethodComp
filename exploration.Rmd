---
title: "Exploration"
author: "Tim Szewczyk"
date: "2/16/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pkgs <- c("fields", "sevcheck", "gbPopMod", "IPMpack", "tidyverse", "magrittr")
suppressMessages(invisible(lapply(pkgs, library, character.only=TRUE)))
theme_set(theme_bw())
source("code/fn_IPM.R"); source("code/fn_aux.R")
lc.df <- read_csv("data/landcover_5km.csv") %>% 
  filter(!is.na(bio1_mean))
```

# Exploration of options for the simulation component

## Species description: Life history, characteristics, relevant attributes
The simulated species is fully described here. The object `sp_i` is a list containing elements for the global parameters, relationships with environmental variables, and demographic matrices that are applicable or potentially applicable for that modeling strategy. Parameters are abbreviated with the associated kernel component (e.g., `s_*` for survival, `g_*` for growth, etc) and the type of covariate (`*_z` for size, `*_x` for environmental covariates).
```{r sp_i}
subsamp <- NA
mean_abund <- 2000
regPlots <- F
ipmPlots <- F
n <- 100  # ncells in IPM matrix
if(is.na(subsamp)) { cells <- 1:n_distinct(lc.df$CellID)
} else { cells <- sample(1:n_distinct(lc.df$CellID), subsamp, replace=FALSE) }
n.cell <- length(cells)
n_i <- rpois(n.cell, mean_abund)
sp_i <- list(p=list(s_z=c(-1.75, .75), # b1 + b2*z
                    s_x=c(1, -.1, -.5, -.1, .05), # b1*x1 + ...
                    g_z=c(.2, 2, -0.1), # b1 + b2*z + b3*z^2
                    g_x=c(1, -.1, 1.5, -.1), #b1*x1 + ...
                    g_sig=1, # growth ~ N(E, g_sig)
                    fl_z=c(-1.5, .1, .1), # b1 + b2*z + b3*z^2 + b4*z^3
                    fl_x=c(1, -.01, -1, -.01, .2), # b1*x1 + ...
                    seed_z=c(2, 0.5, -.03), # b1 + b2*z + b2*z^2
                    seed_x=c(1, -.1, 1, -.1, .2), # b1*x1 + ...
                    rcr_z=c(1.5, 0.4), # N(mean=rcrt1, sd=rcrt2)
                    p_est=0.02, # p(establishment)
                    rcr_SB=0.2, # p(recruit from seedbank)
                    rcr_dir=0.6, # p(recruit directly)
                    s_SB=0.3 # p(survive in seedbank additional year)
                    ))
```

## Landscape
The landscape characteristics are aggregated here. It is a gridded landscape with climate and LULC data.
```{r landscape}
env.df <- tibble(temp=c(scale(lc.df$bio1_mean)),
                 temp2=temp^2,
                 prec=c(scale(lc.df$bio12_mean)),
                 prec2=prec^2,
                 pOpn=c(scale(lc.df$nlcd1_mean)),
                 pOth=c(scale(lc.df$nlcd2_mean)),
                 pDec=c(scale(lc.df$nlcd3_mean)),
                 pEvg=c(scale(lc.df$nlcd4_mean)),
                 pMxd=c(scale(lc.df$nlcd5_mean)),
                 x=lc.df$left,
                 y=lc.df$top)
env.df <- env.df[cells,]
```

---

## Simulation: IPM framework
```{r S}
########
## set up
########
# set up storage objects
p <- sp_i$p
IPMs <- Ps <- Fs <- array(0, dim=c(n+1, n+1, n.cell))
d <- vector("list", length=n.cell)
lambdas <- B_1 <- rep(NA, n.cell)
B <- rpois(n.cell, n_i)

# set up environmental covariates
n_sz <- length(p$s_z); n_sx <- length(p$s_x)
n_gz <- length(p$g_z); n_gx <- length(p$g_x)
n_flz <- length(p$fl_z); n_flx <- length(p$fl_x)
n_seedz <- length(p$seed_z); n_seedx <- length(p$seed_x)
X_s <- as.matrix(env.df[,1:n_sx])
X_g <- as.matrix(env.df[,1:n_gx])
X_fl <- as.matrix(env.df[,1:n_flx])
X_seed <- as.matrix(env.df[,1:n_seedx])


########
## loop through cells
########
for(i in 1:n.cell) {
  d[[i]] <- data.frame(size=runif(n=n_i[i], min=1, max=12))
  lo <- min(d[[i]]$size)*0.75
  hi <- max(d[[i]]$size)*1.25
  size.mx <- cbind(1, d[[i]]$size, d[[i]]$size^2, d[[i]]$size^3)
  
  #---- generate data
  ## survival
  E_surv <- antilogit(size.mx[,1:n_sz] %*% p$s_z + c(X_s[i,] %*% p$s_x))
  d[[i]]$surv <- rbinom(n_i[i], 1, E_surv)
  ## growth
  E_grow <- size.mx[,1:n_gz] %*% p$g_z + c(X_g[i,] %*% p$g_x)
  d[[i]]$sizeNext <- rnorm(n_i[i], E_grow, p$g_sig)
  d[[i]]$sizeNext <- ifelse(d[[i]]$surv, d[[i]]$sizeNext, NA)
  ## flowering 
  E_fl <- antilogit(size.mx[,1:n_flz] %*% p$fl_z + c(X_fl[i,] %*% p$fl_x))
  d[[i]]$fl <- rbinom(n_i[i], 1, E_fl)
  ## seed production
  E_seed <- d[[i]]$fl * 
    exp(size.mx[,1:n_seedz] %*% p$seed_z + c(X_seed[i,] %*% p$seed_x))
  d[[i]]$seed <- rpois(n_i[i], E_seed)
  d[[i]]$fl <- ifelse(d[[i]]$surv, d[[i]]$fl, NA)
  d[[i]]$seed <- ifelse(d[[i]]$fl==1, d[[i]]$seed, NA)
  ## seed bank
  B_1[i] <- B[i] * p$s_SB * (1 - p$rcr_SB) + 
    sum(d[[i]]$seed, na.rm=TRUE) * (1 - p$rcr_dir) * p$s_SB
  ## recruits
  rcrt.n <- max((sum(d[[i]]$seed, na.rm=TRUE) * p$rcr_dir * p$p_est +
                   B[i] * p$rcr_SB * p$p_est), 
                2) # need â‰¥ 2 for IPMpack estimate of rcr_z'_mn, rcr_z'_sd
  rcrt.i <- (n_i[i]+1):(n_i[i]+rcrt.n)
  d[[i]][rcrt.i,] <- NA
  d[[i]]$sizeNext[rcrt.i] <- rnorm(rcrt.n, p$rcr_z[1], p$rcr_z[2])
  
  #---- fill IPM matrices
  ## Underlying Truth: use assigned slopes
  b <- lo + c(0:n)*(hi - lo)/n  # boundary points
  y <- 0.5*(b[1:n] + b[2:(n+1)])  # mesh points
  h <- y[2] - y[1]  # step size
  z.i <- 2:(n+1)  # continuous stage matrix indices
  ### growth and survival
  G.mx <- h*outer(y, y, calc_grow, p=p, n_gz=n_gz, X.g=X_g[i,])
  S.v <- calc_surv(y, p=p, n_sz=n_sz, X.s=X_s[i,])
  ### Fix eviction of individuals below/above size limits
  for(k in 1:(n/2)) G.mx[1,k] <- G.mx[1,k] + 1 - sum(G.mx[,k])
  for(k in (n/2+1):n) G.mx[n,k] <- G.mx[n,k] + 1 - sum(G.mx[,k])
  ### fill P, F, and K
  for(k in z.i) Ps[k,z.i,i] <- G.mx[k-1,]*S.v
  Ps[1,1,i] <- calc_staySB(p)
  Fs[z.i,z.i,i] <- h*outer(y, y, calc_rcrDir, p=p, n_seedz=n_seedz,
                             n_flz=n_flz, X.seed=X_seed[i,], X.fl=X_fl[i,])
  Fs[1,z.i,i] <- calc_addSB(y, p=p, n_seedz=n_seedz, n_flz=n_flz, 
                            X.seed=X_seed[i,], X.fl=X_fl[i,])
  Fs[z.i,1,i] <- calc_rcrSB(y, p)
  IPMs[,,i] <- Ps[,,i] + Fs[,,i]
  
  #---- progress
  if(i %% 100 == 0) cat("Finished cell", i, "\n")
}
lam.df <- env.df
lam.df$lambda <- apply(IPMs, 3, function(x) Re(eigen(x)$values[1]))
ggplot(lam.df, aes(x=x, y=y, fill=log(lambda))) + geom_tile() +
  scale_fill_gradient2(low="darkblue", mid="white", high="darkred", midpoint=0)
par(mfrow=c(2,2))
plot(log(lambda) ~ temp, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambda) ~ prec, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambda) ~ pOpn, data=lam.df); abline(h=0, col="red", lty=2)
plot(density(log(lam.df$lambda))); abline(v=0, col="red", lty=2)

# Plots
if(regPlots) {
  par(mfrow=c(3,2), mar=c(4,4,2,1))
  xx <- tibble(size=seq(lo, hi, length.out=100), size2=size^2, size3=size^3)
  mx <- cbind(1, as.matrix(xx))
  xxx <- seq(0, hi*.5, length.out=100)
  for(i in 1:n.cell) {
    z.t <- d[[i]][!is.na(d[[i]]$size),]; main.i <- paste("Cell", i)
    w1 <- Re(eigen(IPMs[,,i])$vectors[,1])[-1]; stable.dist1 <- w1/sum(w1)
    rcrt.z <- d[[i]]$sizeNext[is.na(d[[i]]$size) & !is.na(d[[i]]$sizeNext)]
    plot(surv~size, data=z.t, ylim=c(0,1), pch=20, col=rgb(0,0,0,0.2),
         main=paste("Surv:", main.i), xlab="Size (t)", ylab="P(surv to t+1)")
      lines(mx[,2], antilogit(mx[,1:n_sz]%*%p$s_z + c(X_s[i,]%*%p$s_x)), col=2)
    plot(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2), 
         main=paste("Growth:", main.i), xlab="Size (t)", ylab="Size (t+1)")
      lines(mx[,2], mx[,1:n_gz]%*%p$g_z + c(X_g[i,]%*%p$g_x), col=2)
      abline(a=0, b=1, lty=2)
    plot(fl~size, data=z.t, pch=20, ylim=c(0,1), col=rgb(0,0,0,0.2),
         main=paste("P(Flower):", main.i), xlab="Size (t)", ylab="P(flower)")
      lines(mx[,2], antilogit(mx[,1:n_flz]%*%p$fl_z + c(X_fl[i,]%*%p$fl_x)),
            col=2)
    plot(seed~size, data=z.t, pch=23-z.t$fl*3, col=rgb(0,0,0,0.2), 
         main=paste("nSeeds:", main.i), xlab="Size (t)", ylab="Number of seeds")
      lines(mx[,2], exp(mx[,1:n_seedz]%*%p$seed_z + c(X_seed[i,]%*%p$seed_x)),
            col=2)
    plot(y, stable.dist1, ylab="", type="l", col=2, 
         main=paste("Stable size distribution:", main.i), xlab="Size (t)")
    hist(d[[i]]$sizeNext[is.na(d[[i]]$size)], col="grey", freq=FALSE, 
         main=paste("Recruit sizes:", main.i), xlab="Recruit size (t+1)")
      lines(xxx, dnorm(xxx, p$rcr_z[1], p$rcr_z[2]), col="red", lwd=2)
  }
}
if(ipmPlots) {
  par(mfrow=c(2,2), mar=c(4,4,2,1))
  x <- c(0, y)
  for(i in 1:n.cell) {
    z.t <- d[[i]][!is.na(d[[i]]$size),]; main.i <- paste("Cell", i)
    z.t$y <- y[findInterval(z.t$size, y, all.inside=TRUE)]
    totSeeds <- group_by(z.t, y) %>% summarise(seed=sum(seed, na.rm=TRUE))
    image.plot(x, x, t(Ps[,,i]), main=paste("P matrix:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
      points(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,1/(n_i[i]^.25)))
      abline(a=0, b=1, col="white", lty=2)
    image.plot(x, x, t(Fs[,,i]), main=paste("F matrix:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
      points(totSeeds$y, totSeeds$seed/max(totSeeds$seed)*hi*.9)
    image.plot(x, x, t(sens(IPMs[,,i])), main=paste("Sensitivity:", main.i), 
               xlab="Size (t)", ylab="Size (t+1)")
    image.plot(x, x, t(elas(IPMs[,,i])), main=paste("Elasticity:", main.i),
               xlab="Size (t)", ylab="Size (t+1)")
  }
}
```

----

## Observed datasets
The simulated species *S* is sampled appropriately in order to fit each SDM model. The observed datasets,*O*, may be random or intentionally biased to mimic common issues with empirical data.
### Correlative: MaxEnt
```{r O_Mx}

```
### Mechanistic: CA
```{r O_CA}

```
### Mechanistic: IPM
```{r O_IPM}

```

---

## Fitting the models
Each observed dataset *O* is used to predict the distribution of species *S*. The predicted distribution *P* is compared to the known truth *S* to assess the predictive accuracy of each modeling approach, given any limitations, uncertainty, or bias imposed in *O*. 
### Correlative: MaxEnt
```{r P_Mx}

```
### Mechanistic: CA
```{r P_CA}

```
### Mechanistic: IPM
```{r P_IPM}
for(i in 1:ncell) {
  # ## IPMpack: estimate slopes from d[[i]]
  # ### set up seedbank transitions
  d[[i]]$stage <- d[[i]]$stageNext <- "continuous"
  d[[i]]$stage[is.na(d[[i]]$size)] <- NA
  d[[i]]$stageNext[d[[i]]$surv==0] <- "dead"
  d[[i]]$number <- 1
  seedbank <- data.frame(size=NA, surv=1, sizeNext=NA,
                         fl=NA, seed=NA,
                         stage=c("seedbank", "seedbank", "continuous"),
                         stageNext=c("seedbank", "continuous", "seedbank"),
                         number=c(p$s_SB * (1 - p$rcr_SB), 
                                  p$rcr_SB * p$p_est, 
                                  (1 - p$rcr_dir) * p$s_SB))
  d[[i]] <- rbind(d[[i]], seedbank)
  d[[i]]$stage <- as.factor(d[[i]]$stage)
  d[[i]]$stageNext <- as.factor(d[[i]]$stageNext)
  ### construct kernels
  so <- makeSurvObj(d[[i]], surv ~ size)
  go <- makeGrowthObj(d[[i]], sizeNext ~ size + size2)
  fo <- makeFecObj(d[[i]],
                   Formula=c(fl~size+size2, seed~size+size2),
                   Family=c("binomial", "poisson"),
                   Transform=c("none", "none"),
                   meanOffspringSize=mean(
                     d[[i]]$sizeNext[is.na(d[[i]]$size) &
                                       !is.na(d[[i]]$sizeNext)]),
                   sdOffspringSize=sd(
                     d[[i]]$sizeNext[is.na(d[[i]]$size) &
                                       !is.na(d[[i]]$sizeNext)]),
                   fecConstants=data.frame(seedlingEstablishmentRate=p$p_est),
                   offspringSplitter=data.frame(seedbank=(1-p$rcr_dir),
                                                continuous=p$rcr_dir)
                   )
  F.mx2 <- makeIPMFmatrix(fecObj=fo, minSize=lo, maxSize=hi,
                          correction="constant")
  D.mx2 <- makeDiscreteTrans(d[[i]], 
                             continuousToDiscreteExplanatoryVariables=1)
  dummy <- as.matrix(fo@offspringRel$coefficients[1], list(1, "seedbank"))
  D.mx2@meanToCont <- as.matrix(dummy, dimnames=c(1, "seedbank"))
  dummy <- as.matrix(fo@sdOffspringSize, dimnames=list(1, "seedbank"))
  D.mx2@sdToCont <- as.matrix(dummy, dimnames=c(1, "seedbank"))
  D.mx2@discreteTrans[1,1] <- p$s_SB * (1 - p$rcr_SB)
  D.mx2@discreteTrans[3,1] <- 1 - sum(D.mx2@discreteTrans[1:2,1])
  P.mx2 <- makeIPMPmatrix(growObj=go, survObj=so, discreteTrans=D.mx2,
                            minSize=lo, maxSize=hi, correction="constant")
  IPM2 <- P.mx2 + F.mx2
  lambdas2[i] <- Re(eigen(IPM2)$values[1])
  
  if(regPlots) {
    par(mfrow=c(3,2), mar=c(4,4,2,1))
    xx <- tibble(size=seq(lo, hi, length.out=100), size2=size^2, size3=size^3)
    plot(surv~size, data=d[[i]], ylim=c(0,1), pch=20, col=rgb(0,0,0,0.2),
         main=paste("Surv:", main.i), xlab="Size (t)", ylab="P(surv to t+1)")
      points(z.t$size, E_surv, cex=0.2, col="red")
      # lines(xx$size, predict(so@fit, xx, type="response"), col="blue")
    plot(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2), 
         main=paste("Growth:", main.i), xlab="Size (t)", ylab="Size (t+1)")
      points(z.t$size, E_grow, cex=0.2, col="red")
      # lines(xx$size, predict(go@fit, xx, type="response"), col="blue")
      abline(a=0, b=1, lty=2)
    plot(fl~size, data=z.t, pch=20, ylim=c(0,1), col=rgb(0,0,0,0.2),
         main=paste("P(Flower):", main.i), xlab="Size (t)", ylab="P(flower)")
      points(z.t$size, E_fl, cex=0.2, col="red")
      # lines(xx$size, predict(fo@fitFec[[1]], xx, type="response"), col="blue")
    plot(seed~size, data=z.t, pch=23-z.t$fl*3, col=rgb(0,0,0,0.2), 
         main=paste("nSeeds:", main.i), xlab="Size (t)", ylab="Number of seeds")
      points(z.t$size, E_seed, cex=0.2, col="red")
      # lines(xx$size, predict(fo@fitFec[[2]], xx, type="response"), col="blue")
    w1 <- Re(eigen(IPMs[,,i])$vectors[,1])[-1]; stable.dist1 <- w1/sum(w1)
    # w2 <- Re(eigen(IPM2)$vectors[,1])[-1]; stable.dist2 <- w2/sum(w2)
    yl <- range(stable.dist1)#range(c(stable.dist1, stable.dist2))
    plot(y, stable.dist1, ylab="", type="l", lwd=2, col="red", ylim=yl,
         main=paste("Stable size distribution:", main.i), xlab="Size (t)")
    # lines(y, stable.dist2, col="blue")
    hist(d[[i]]$sizeNext[rcrt.i], main=paste("Recruit sizes:", main.i), 
         xlab="Recruit size (t+1)", col="grey", freq=FALSE)
      xxx <- seq(0, hi*.5, length.out=100)
      rcrt.z <- d[[i]]$sizeNext[is.na(d[[i]]$size) & !is.na(d[[i]]$sizeNext)]
      lines(xxx, dnorm(xxx, p$rcr_z[1], p$rcr_z[2]), col="red", lwd=2)
      # lines(xxx, dnorm(xxx, mean(rcrt.z), sd(rcrt.z)), col="blue")
  }
}


```



