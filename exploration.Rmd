---
title: "Exploration"
author: "Tim Szewczyk"
date: "2/16/2018"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
pkgs <- c("fields", "sevcheck", "gbPopMod", "IPMpack", "tidyverse", "magrittr")
suppressMessages(invisible(lapply(pkgs, library, character.only=TRUE)))
theme_set(theme_bw())
lc.df <- read_csv("data/landcover_5km.csv") %>% 
  filter(!is.na(bio1_mean))
```

# Exploration of options for the simulation component

## Species description: Life history, characteristics, relevant attributes
The simulated species is fully described here. The object `sp_i` is a list containing elements for the global parameters, relationships with environmental variables, and demographic matrices that are applicable or potentially applicable for that modeling strategy. Parameters are abbreviated with the associated kernel component (e.g., `s_` for survival, `g_` for growth, etc) and the type of covariate (`_z` for size, `_x` for environmental covariates).
```{r sp_i}
#set.seed(20)
subsamp <- NA
mean_abund <- 2000
regPlots <- F
ipmPlots <- F
if(is.na(subsamp)) { cells <- 1:n_distinct(lc.df$CellID)
} else { cells <- sample(1:n_distinct(lc.df$CellID), subsamp, replace=FALSE) }
n.cell <- length(cells)
n_i <- rpois(n.cell, mean_abund)
sp_i <- list(p=list(s_z=c(-4, .75), # b1 + b2*z
                    s_x=c(1, -.1, 1, -.1), # b1*x1 + ...
                    g_z=c(.2, 2, -0.1), # b1 + b2*z + b3*z^2
                    g_x=c(1, -.1, 1, -.1), #b1*x1 + ...
                    g_sig=1, # N(E, sig)
                    fl_z=c(-3, .6), # b1 + b2*z
                    fl_x=c(1, -.01, 1, -.01), # b1*x1 + ...
                    seed_z=c(2, 0.5, -.03), # b1 + b2*z + b2*z^2
                    seed_x=c(1, -.1, 1, -.1), # b1*x1 + ...
                    rcrt=c(1.5, 0.4), #N(mean=rcrt1, sd=rcrt2)
                    p_est=0.02))
```

## Landscape
The landscape characteristics are aggregated here. It is a gridded landscape with climate and LULC data.
```{r landscape}
env.df <- tibble(temp=c(scale(lc.df$bio1_mean)),
                 temp2=temp^2,
                 prec=c(scale(lc.df$bio12_mean)),
                 prec2=prec^2,
                 pOpn=c(scale(lc.df$nlcd1_mean)),
                 pOth=c(scale(lc.df$nlcd2_mean)),
                 pDec=c(scale(lc.df$nlcd3_mean)),
                 pEvg=c(scale(lc.df$nlcd4_mean)),
                 pMxd=c(scale(lc.df$nlcd5_mean)),
                 x=lc.df$left,
                 y=lc.df$top)
env.df <- env.df[cells,]
```

---

## Simulation: IPM framework
```{r S}
########
## set up
########
# set up storage objects
p <- sp_i$p
d <- vector("list", length=n.cell)
lambdas <- lambdas2 <- rep(NA, n.cell)

# set up environmental covariates
n_sz <- length(p$s_z); n_sx <- length(p$s_x)
n_gz <- length(p$g_z); n_gx <- length(p$g_x)
n_flz <- length(p$fl_z); n_flx <- length(p$fl_x)
n_seedz <- length(p$seed_z); n_seedx <- length(p$seed_x)
X_s <- as.matrix(env.df[,1:n_sx])
X_g <- as.matrix(env.df[,1:n_gx])
X_fl <- as.matrix(env.df[,1:n_flx])
X_seed <- as.matrix(env.df[,1:n_seedx])

# life history functions
z_pow <- function(z.vec, n_z) {
  if(n_z==1) {
    return(matrix(1, ncol=1, nrow=length(z.vec)))
  } else {
    z <- matrix(z.vec, nrow=length(z.vec), ncol=n_z-1)
    for(i in 1:(n_z-1)) z[,i] <- z[,i]^i
    z <- cbind(1, z)
    return(z)
  }
}
calc_surv <- function(z.v, n_sz, p, X.s) {
  z <- z_pow(z.v, n_sz)
  u <- exp(z %*% p$s_z + c(t(X.s) %*% p$s_x))
  return(u / (1+u))
}
calc_grow <- function(z1, z.v, n_gz, p, X.g) {
  z <- z_pow(z.v, n_gz)
  g <- dnorm(z1, mean=z %*% p$g_z + c(t(X.g) %*% p$g_x), 
             sd=p$g_sig)
  return(g)
}
calc_flwr <- function(z.v, n_flz, p, X.fl) {
  z <- z_pow(z.v, n_flz)
  u <- exp(z %*% p$fl_z + c(t(X.fl) %*% p$fl_x))
  return(u / (1+u))
}
calc_seed <- function(z1, z.v, n_seedz, n_flz, p, X.seed, X.fl) {
  z <- z_pow(z.v, n_seedz)
  calc_flwr(z.v, n_flz, p, X.fl) * p$p_est *
      dnorm(z1, p$rcrt[1], p$rcrt[2]) *
      exp(z %*% p$seed_z + c(t(X.seed) %*% p$seed_x))
}

########
## loop through cells
########
for(i in 1:n.cell) {
  d[[i]] <- data.frame(size=runif(n=n_i[i], min=1, max=12))
  lo <- min(d[[i]]$size)*0.8
  hi <- max(d[[i]]$size)*1.1
  size.mx <- cbind(1, d[[i]]$size, d[[i]]$size^2, d[[i]]$size^3)
  
  # generate data
  ## survival
  E_surv <- antilogit(size.mx[,1:n_sz] %*% p$s_z + c(X_s[i,] %*% p$s_x))
  d[[i]]$surv <- rbinom(n_i[i], 1, E_surv)
  
  ## growth
  E_grow <- size.mx[,1:n_gz] %*% p$g_z + c(X_g[i,] %*% p$g_x)
  d[[i]]$sizeNext <- rnorm(n_i[i], E_grow, p$g_sig)
  d[[i]]$sizeNext <- ifelse(d[[i]]$surv, d[[i]]$sizeNext, NA)
  
  ## flowering 
  E_fl <- antilogit(size.mx[,1:n_flz] %*% p$fl_z + c(X_fl[i,] %*% p$fl_x))
  d[[i]]$fl <- rbinom(n_i[i], 1, E_fl)
  
  ## seed production
  E_seed <- d[[i]]$fl * exp((size.mx[,1:n_seedz] %*% p$seed_z + 
                               c(X_seed[i,] %*% p$seed_x)))
  d[[i]]$seed <- rpois(n_i[i], E_seed)
  d[[i]]$seed <- ifelse(d[[i]]$fl, d[[i]]$seed, NA)
  seed.range <- range(d[[i]]$seed, na.rm=TRUE)
  
  ## recruits
  rcrt.n <- max(sum(d[[i]]$seed, na.rm=TRUE)*p$p_est, 2)
  rcrt.i <- (n_i[i]+1):(n_i[i]+rcrt.n)
  d[[i]][rcrt.i,] <- NA
  d[[i]]$sizeNext[rcrt.i] <- rnorm(rcrt.n, p$rcrt[1], p$rcrt[2])
  
  # fill IPM matrices
  ## Manual: use assigned slopes
  n <- 50  # ncells in matrix
  b <- lo + c(0:n)*(hi - lo)/n  # boundary points
  y <- 0.5*(b[1:n] + b[2:(n+1)])  # mesh points
  h <- y[2] - y[1]  # step size
  
  G.mx <- h*outer(y, y, calc_grow, n_gz=n_gz, p=p, X.g=X_g[i,])
  S.v <- calc_surv(y, n_sz, p, X_s[i,])
  F.mx <- h*outer(y, y, calc_seed, n_seedz=n_seedz, p=p, n_flz=n_flz,
                  X.seed=X_seed[i,], X.fl=X_fl[i,])
  P.mx <- G.mx
  for(k in 1:(n/2)) { # Fix eviction of individuals below/above size limits
    G.mx[1,k] <- G.mx[1,k] + 1 - sum(G.mx[,k])
    P.mx[,k] <- G.mx[,k]*S.v[k]
  }
  for(k in (n/2+1):n) {
    G.mx[n,k] <- G.mx[n,k] + 1 - sum(G.mx[,k])
    P.mx[,k] <- G.mx[,k]*S.v[k]
  }
  IPM <- P.mx + F.mx
  
  ## IPMpack: estimate slopes from d[[i]]
  so <- makeSurvObj(d[[i]], surv ~ size)
  go <- makeGrowthObj(d[[i]], sizeNext ~ size + size2)
  fo <- makeFecObj(d[[i]],
                   Formula=c(fl~size, seed~size+size2),
                   Family=c("binomial", "poisson"),
                   Transform=c("none", "none"),
                   fecConstants=data.frame(seedlingEstablishmentRate=p$p_est))
  P.mx2 <- makeIPMPmatrix(growObj=go, survObj=so, minSize=lo, maxSize=hi,
                         correction="constant")
  F.mx2 <- makeIPMFmatrix(fecObj=fo, minSize=lo, maxSize=hi,
                          correction="constant")
  IPM2 <- P.mx2 + F.mx2
  
  lambdas[i] <- Re(eigen(IPM)$values[1])
  lambdas2[i] <- Re(eigen(IPM2)$values[1])
  
  # Plots
  z.t <- d[[i]][!is.na(d[[i]]$size),]; main.i <- paste("Cell", i)
  if(regPlots) {
    par(mfrow=c(3,2), mar=c(4,4,2,1))
    xx <- tibble(size=seq(lo, hi, length.out=100), size2=size^2, size3=size^3)
    plot(surv~size, data=d[[i]], ylim=c(0,1), pch=20, col=rgb(0,0,0,0.2),
         main=paste("Surv:", main.i), xlab="Size (t)", ylab="P(surv to t+1)")
      points(z.t$size, E_surv, cex=0.2, col="red")
      lines(xx$size, predict(so@fit, xx, type="response"), col="blue")
    plot(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2), 
         main=paste("Growth:", main.i), xlab="Size (t)", ylab="Size (t+1)")
      points(z.t$size, E_grow, cex=0.2, col="red")
      lines(xx$size, predict(go@fit, xx, type="response"), col="blue")
      abline(a=0, b=1, lty=2)
    plot(fl~size, data=z.t, pch=20, ylim=c(0,1), col=rgb(0,0,0,0.2),
         main=paste("P(Flower):", main.i), xlab="Size (t)", ylab="P(flower)")
      points(z.t$size, E_fl, cex=0.2, col="red")
      lines(xx$size, predict(fo@fitFec[[1]], xx, type="response"), col="blue")
    plot(seed~size, data=z.t, pch=23-z.t$fl*3, col=rgb(0,0,0,0.2), 
         main=paste("nSeeds:", main.i), xlab="Size (t)", ylab="Number of seeds")
      points(z.t$size, E_seed, cex=0.2, col="red")
      lines(xx$size, predict(fo@fitFec[[2]], xx, type="response"), col="blue")
    w1 <- Re(eigen(IPM)$vectors[,1]); stable.dist1 <- w1/sum(w1)
    w2 <- Re(eigen(IPM2)$vectors[,1]); stable.dist2 <- w2/sum(w2)
    yl <- range(c(stable.dist1, stable.dist2))
    plot(y, stable.dist1, ylab="", type="l", lwd=2, col="red", ylim=yl,
         main=paste("Stable size distribution:", main.i), xlab="Size (t)")
    lines(y, stable.dist2, lwd=2, lty=2, col="blue")
    # plot(y, S.v); points(y, apply(P.mx, 2, sum), col="red", type="l")
    hist(d[[i]]$sizeNext[rcrt.i], main=paste("Recruit sizes:", main.i), 
         xlab="Recruit size (t+1)", col="grey", freq=FALSE)
      xxx <- seq(0, hi*.5, length.out=100)
      lines(xxx, dnorm(xxx, p$rcrt[1], p$rcrt[2]), col="red")
  }
  if(ipmPlots) {
    par(mfrow=c(2,2), mar=c(4,4,2,1)); main.i <- paste("Cell", i)
    # sens.mx <- sens(IPM2); elas.mx <- elas(IPM2)
    sens.mx <- sens(IPM); elas.mx <- elas(IPM)
    image.plot(y, y, t(P.mx), main=main.i, xlab="Size (t)", ylab="Size (t+1)")
      points(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2))
      abline(a=0, b=1, col="white", lty=2)
    image.plot(y, y, t(P.mx2), main=main.i, xlab="Size (t)", ylab="Size (t+1)")
      points(sizeNext~size, data=z.t, pch=20, col=rgb(0,0,0,0.2))
      abline(a=0, b=1, col="white", lty=2)
    image.plot(1:dim(sens.mx)[1], 1:dim(sens.mx)[1], t(sens.mx),
               main=paste("Sens:", main.i), xlab="Size (t)", ylab="Size (t+1)")
    image.plot(1:dim(elas.mx)[1], 1:dim(elas.mx)[1], t(elas.mx),
               main=paste("Elas:", main.i), xlab="Size (t)", ylab="Size (t+1)")
  }
  if(i %% 100 == 0) cat("Finished cell", i, "\n")
}
lam.df <- env.df %>% add_column(lambda=lambdas, lambda2=lambdas2)
ggplot(lam.df, aes(x=x, y=y, fill=log(lambdas))) + geom_tile() +
  scale_fill_gradient2(low="darkblue", mid="white", high="darkred", midpoint=0)
ggplot(lam.df, aes(x=x, y=y, fill=log(lambdas2))) + geom_tile() +
  scale_fill_gradient2(low="darkblue", mid="white", high="darkred", midpoint=0)
par(mfrow=c(2,2))
plot(log(lambdas) ~ temp, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambdas) ~ prec, data=lam.df); abline(h=0, col="red", lty=2)
plot(log(lambdas), log(lambdas2)); abline(v=0, h=0, a=0, b=1, lty=c(3,2,2))
plot(density(log(lambdas))); abline(v=0, col="red", lty=2)
```

----

## Observed datasets
The simulated species *S* is sampled appropriately in order to fit each SDM model. The observed datasets,*O*, may be random or intentionally biased to mimic common issues with empirical data.
### Correlative: MaxEnt
```{r O_Mx}

```
### Mechanistic: CA
```{r O_CA}

```
### Mechanistic: IPM
```{r O_IPM}

```

---

## Fitting the models
Each observed dataset *O* is used to predict the distribution of species *S*. The predicted distribution *P* is compared to the known truth *S* to assess the predictive accuracy of each modeling approach, given any limitations, uncertainty, or bias imposed in *O*. 
### Correlative: MaxEnt
```{r P_Mx}

```
### Mechanistic: CA
```{r P_CA}

```
### Mechanistic: IPM
```{r P_IPM}

```



