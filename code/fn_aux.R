# Auxilliary functions
# Comparison of SDM approaches
# Tim Szewczyk


##-- antilogit
#' Take the antilogit of the input
#' @param x Scalar, vector, or matrix of values
antilogit <- function (x) {
  exp(x)/(1 + exp(x))
}



##-- logit
#' Take the logit of the input
#' @param x Scalar, vector, or matrix of probabilities
logit <- function (x) {
  log(x/(1-x))
}



##-- generate landscape 
#' Assemble the necessary landscape files. This aggregates NLCD categories and
#' extracts the specified bioclimatic variables, returning one full-grid
#' dataframe with variables scaled, one full-grid dataframe with raw values, one
#' in-bound dataframe with scaled values, and an index for the scaling.
#' @param f Landscape grid file (e.g., ENF_50km.csv)
#' @param nlcd_agg Dataframe with NLCD aggregation scheme
#' @param clim_X Column names for bioclimatic variables to include. Defaults to 
#' all 19 variables
#' @param x_max \code{Inf} Maximum number of rows in grid (Inf = full-scale)
#' @param y_max \code{Inf} Maximum number of columns in grid (Inf = full-scale)
build_landscape <- function(f, nlcd_agg, clim_X=paste0("bio10_", 1:19), 
                            x_max=Inf, y_max=Inf) {
  library(tidyverse)
  # load GIS data & create x-y columns for landscape grid
  f.df <- suppressMessages(read_csv(f)) %>% 
    mutate(x=as.integer(factor(.$long)),
           y=as.integer(factor(.$lat, levels=rev(levels(factor(.$lat))))),
           x_y=paste(x, y, sep="_"))
  lc.cat <- unique(nlcd_agg$agg)
  n_lc <- length(lc.cat)
  n_clim <- length(clim_X)
  # aggregate NLCD categories as detailed in nlcd_agg
  nlcd_agg$orig <- paste0("nlcd_", nlcd_agg$orig)
  agg.mx <- matrix(nrow=nrow(f.df), ncol=n_lc)
  colnames(agg.mx) <- lc.cat
  for(i in 1:n_lc) {
    agg.mx[,i] <- rowSums(f.df[, with(nlcd_agg, orig[agg==lc.cat[i]])])
  }
  # assemble specified variables
  l.df <- cbind(f.df[, c("long", "lat", "x", "y", "x_y", clim_X)], agg.mx) %>%
    filter(x <= x_max & y <= y_max)
  # center & scale covariates, store center & scale
  l.scale <- select(l.df, -(1:5)) %>% scale
  scale.i <- cbind(sc_mn=attributes(l.scale)$`scaled:center`,
                   sc_sd=attributes(l.scale)$`scaled:scale`)
  rownames(scale.i) <- colnames(l.scale)
  # establish rectangular grid with x=1:ncol, y=1:nrow
  rct <- as.tibble(expand.grid(x=1:max(l.df$x), y=1:max(l.df$y))) %>%
    mutate(x_y=paste(x, y, sep="_")) 
  match_id <- match(rct$x_y, l.df$x_y)
  # pair scaled environmental variables with rectangular grid
  l.rct <- l.scale[match_id, rep(1:ncol(l.scale), rep(2:1, c(n_clim, n_lc)))]
  l.rct[,2*(1:n_clim)] <- l.rct[,2*(1:n_clim)]^2
  colnames(l.rct)[2*(1:n_clim)] <- paste0(colnames(l.rct)[2*(1:n_clim)], "_sq")
  env.rct <- cbind(l.rct, rct) %>%
    mutate(inbd=!is.na(match(.$x_y, l.df$x_y)),
           lat=l.df$lat[match_id],
           lon=l.df$long[match_id],
           rdLen=f.df$rd_len[match_id]) %>%
    mutate(id=row_number(), 
           id.inbd=min_rank(na_if(inbd*id, 0)))
  # env.rct[is.na(env.rct)] <- 0
  # pair unscaled environmental variables (required for dispersal probabilities)
  env.rct.unscaled <- cbind(env.rct[,-(1:(n_lc+n_clim*2))], 
                            l.df[match_id,-(1:5)])
  # subset inbound cells
  env.in <- filter(env.rct, inbd)
  return(list(env.rct=env.rct, env.rct.unscaled=env.rct.unscaled,
              env.in=env.in, scale.i=scale.i))
}



##-- create design matrix from vector of individual sizes
#' From a vector of sizes \code{z.vec}, generate a design matrix with a column 
#' 1's, a column of \code{z.vec}, a column of \code{z.vec^2}, ..., a column of 
#' \code{z.vec^n_z}
#' @param z.vec Vector of individual sizes, with one value for each individual 
#' in the population
#' @param n_z Largest exponent desired for \code{z.vec}
z_pow <- function(z.vec, n_z) {
  if(n_z==1) {
    return(matrix(1, ncol=1, nrow=length(z.vec)))
  } else {
    z <- matrix(z.vec, nrow=length(z.vec), ncol=n_z-1)
    for(i in 1:(n_z-1)) z[,i] <- z[,i]^i
    z <- cbind(1, z)
    return(z)
  }
}




##-- aggregate multiple demographic CA simulations
#' Aggregate output from a list of demographic cellular automata simulations 
#' into a list of arrays suitable for summarizing across simulations. 
#' @param sim.ls A list of simulations where each element of the list was 
#' generated by gbPopMod::run_sim()
#' @param y.ad Maximum age (year) of maturity in CA-d simulations; equivalent to
#' \code{max(CA_params$m)}; \code{?gbPopMod::set_g_p}
#' @return List of arrays with elements for P = adult presence, B = seed 
#' abundance, nSd = number of seeds produced, nSdStay = number of seeds 
#' remaining in source cell, D = number of immigrant seeds, N_tot = total 
#' non-seed abundance, N_ad = adult abundance, N_rcr = number of seedlings. 
#' Arrays include dimensions for grid cell, time, and simulation
aggregate_CAd_simulations <- function(sim.ls, y.ad) {
  library(tidyverse)
  l <- list(P=map(sim.ls, ~.$N[,,y.ad]>0),
            B=map(sim.ls, ~.$B),
            nSd=map(sim.ls, ~.$nSd),
            nSdStay=map(sim.ls, ~.$nSdStay),
            D=map(sim.ls, ~.$D),
            N_tot=map(sim.ls, ~apply(.$N, 1:2, sum)),
            N_ad=map(sim.ls, ~.$N[,,y.ad]),
            N_rcr=map(sim.ls, ~.$N[,,1]))
  return(map(l, simplify2array))
}



##-- aggregate multiple individual CA simulations
#' Aggregate output from a list of individual-based cellular automata 
#' simulations into a list of arrays suitable for summarizing across simulations. 
#' @param sim.ls A list of simulations where each element of the list was 
#' generated by simulate_data()
#' @param tmax Maximum time step in simulations
#' @return List of arrays with elements for P = adult presence in final year, B = seed 
#' abundance, nSd = number of seeds produced, D = number of immigrant seeds, 
#' p_est = establishment probability, N_tot = total non-seed abundance including
#' new recruits, N_surv = abundance of individuals >1 year, N_rcr = number of 
#' seedlings. Arrays include dimensions for grid cell, time, and simulation
aggregate_CAi_simulations <- function(sim.ls, tmax) {
  library(tidyverse)
  l <- list(P=map(sim.ls, ~map_dbl(.$d, ~sum(.$surv[.$yr==tmax], na.rm=T))>0),
            B=map(sim.ls, ~.$B),
            nSd=map(sim.ls, ~.$nSd),
            D=map(sim.ls, ~.$D),
            p_est=map(sim.ls, ~.$p_est.i),
            N_tot=map(sim.ls, 
                      ~map_dbl(.$d, ~sum(!is.na(.$sizeNext[.$yr==tmax])))),
            N_surv=map(sim.ls, 
                       ~map_dbl(.$d, ~sum(.$surv[.$yr==tmax], na.rm=T))),
            N_rcr=map(sim.ls, ~map_dbl(.$d, ~sum(is.na(.$size[.$yr==tmax])))))
  return(map(l, simplify2array))
}



##-- calculate means across multiple samples for demographic CA simulations
#' Summarize demographic CA simulations across multiple samples.
#' @param CA.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from aggregate_CAd_simulations()
#' @param in.id Vector of rectangular id's for inbound cells (i.e., lam.df$id)
#' @return List with elements for prP = probability of presence, B.mn = mean
#' seed bank abundance, nSd.mn = mean number of seeds produced, nSdStay.mn = 
#' mean number of local seeds deposited, D.mn = mean number of immigrant seeds,
#' N_tot.mn = mean total abundance, N_ad.mn = mean adult abundance, N_rcr.mn = 
#' mean seedling abundance
summarize_CAd_samples <- function(CA.f, in.id) {
  Sa <- list(P=map(CA.f, ~.$P),
             B=map(CA.f, ~.$B),
             nSd=map(CA.f, ~.$nSd),
             nSdStay=map(CA.f, ~.$nSdStay),
             D=map(CA.f, ~.$D),
             N_tot=map(CA.f, ~.$N_tot),
             N_ad=map(CA.f, ~.$N_ad),
             N_rcr=map(CA.f, ~.$N_rcr)) %>%
    map(simplify2array)
  return(list(prP=apply(Sa$P[in.id,,,], 1:2, mean, na.rm=T),
              B.mn=apply(Sa$B[in.id,,,], 1:2, mean, na.rm=T),
              nSd.mn=apply(Sa$nSd[in.id,,,], 1:2, mean, na.rm=T),
              nSdStay.mn=apply(Sa$nSdStay[in.id,,,], 1:2, mean, na.rm=T),
              D.mn=apply(Sa$D[in.id,,,], 1:2, mean, na.rm=T),
              N_tot.mn=apply(Sa$N_tot[in.id,,,], 1:2, mean, na.rm=T),
              N_ad.mn=apply(Sa$N_ad[in.id,,,], 1:2, mean, na.rm=T),
              N_rcr.mn=apply(Sa$N_rcr[in.id,,,], 1:2, mean, na.rm=T)))
}



##-- calculate means across multiple samples for IPM & individual CA simulations
#' Summarize IPM and individual CA simulations across multiple samples. As 
#' throughout, 'U' refers to the theoretical IPM output and 'S' refers to the
#' individual CA simulations.
#' @param U.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from fill_IPM_matrices()
#' @param S.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from aggregate_CAi_simulations()
#' @return List with elements for 1: Uf, containing {prP = probability of 
#' lambda>1, lam.mn = mean(lambda), IPM.mn = mean(IPM matrix), P.mn = 
#' mean(P matrix), and F.mn = mean(F matrix)}, and 2: Sf, containing prP = 
#' probability of presence, B.mn = mean seed bank abundance, nSd.mn = mean 
#' number of seeds produced, D.mn = mean number of immigrant seeds, p_est.mn = 
#' mean establishment probability, N_tot.mn = mean total abundance, N_surv.mn = 
#' mean abundance of individuals >1 year, N_rcr.mn = mean seedling abundance
summarize_IPM_CAi_samples <- function(U.f, S.f) {
  Ua <- list(IPMs=map(U.f, ~.$IPMs),
             Ps=map(U.f, ~.$Ps),
             Fs=map(U.f, ~.$Fs)) %>% 
    map(simplify2array)
  Ua_lam <- apply(Ua$IPMs, 3:4, function(x) Re(eigen(x)$values[1]))
  Uf <- list(prP=apply(Ua_lam>=1, 1, mean),
             lam.mn=apply(Ua_lam, 1, mean),
             IPM.mn=apply(Ua$IPMs, 1:3, mean),
             P.mn=apply(Ua$Ps, 1:3, mean),
             F.mn=apply(Ua$Fs, 1:3, mean))
  Sa <- list(P=map(S.f, ~.$P),
             B=map(S.f, ~.$B),
             nSd=map(S.f, ~.$nSd),
             D=map(S.f, ~.$D),
             p_est=map(S.f, ~.$p_est),
             N_tot=map(S.f, ~.$N_tot),
             N_surv=map(S.f, ~.$N_surv),
             N_rcr=map(S.f, ~.$N_rcr)) %>%
    map(simplify2array)
  Sf <- list(prP=apply(Sa$P, 1, mean),
             B.mn=apply(Sa$B, 1:2, mean),
             nSd.mn=apply(Sa$nSd, 1:2, mean),
             D.mn=apply(Sa$D, 1:2, mean),
             p_est.mn=apply(Sa$p_est, 1:2, mean),
             N_tot.mn=apply(Sa$N_tot, 1, mean),
             N_surv.mn=apply(Sa$N_surv, 1, mean),
             N_rcr.mn=apply(Sa$N_rcr, 1, mean))
  return(list(Uf=Uf, Sf=Sf))
}



##-- extract SDM sampling & modeling issues from file names
#' Extract the SDM method and the modeling issue from the file names
#' @param f Vector of file names for the predicted distributions generated in 
#' 3_fitModels.R, with the structure of 'P_SDMtype_Issue.rds'
#' @return List with an element for each file, where each element is a vector
#' of c("SDMtype", "Issue")
extract_SDM_details <- function(f) {
  library(stringr)
  str_split(str_remove(str_split(f, "P_", Inf, T)[,2], ".rds"), "_")
}



##-- fit vital rate regressions for PNAS 2017 species
#' For a specified species, fit vital rate regressions using the defined 
#' climatic variables and maximum size exponent. 
#' @param sp \code{"barberry"} One of 'barberry', 'lindera', 'garlic_mustard', 
#' or 'tower_mustard'
#' @param nlcd_agg Dataframe with NLCD aggregation scheme
#' @param clim_X \code{"bio10_1"} Column names for bioclimatic variables to
#'  include
#' @param clim_sq \code{TRUE} Include square of each clim_X?
#' @param n_z \code{3} Maximum exponent to raise the size distribution to
#' @return List of parameters for all vital rate regressions, in addition to
#' rcr_z, z.rng, rcr_dir, p_est, and s_SB
fit_PNAS_species <- function(sp="barberry", nlcd_agg, clim_X="bio10_1", 
                             clim_sq=TRUE, n_z=3) {
  ##-- Set up
  library(tidyverse); library(magrittr); library(here); library(MuMIn)
  walk(paste0("code/fn_", c("IPM", "aux", "sim"), ".R"), ~source(here(.)))
  plot_i <- suppressMessages(read_csv("data/PNAS_2017/plot_coords.csv"))
  env.in <- build_landscape(f="data/ENF_5km.csv", nlcd_agg=nlcd_agg,
                            clim_X=clim_X, x_max=Inf, y_max=150)$env.in
  n.cell <- sum(env.in$inbd)
  sp.ls <- readRDS("data/PNAS_2017/species_data_list.rds")
  
  # extract covariates for cells containing PNAS plots: 5km grid cells
  plot_i$id.inbd <- NA
  for(i in 1:nrow(plot_i)) {
    plot_i$id.inbd[i] <- env.in$id.inbd[abs(env.in$lon-plot_i$lon[i]) < 2500 & 
                                          abs(env.in$lat-plot_i$lat[i]) < 2500]
  }
  X.df <- right_join(env.in, plot_i, by="id.inbd")
  vars <- rep(0, 1+n_z+sum(grepl("bio", names(env.in))))
  if(n_z>1) {
    names(vars) <- c("(Intercept)", "size", paste0("size", 2:n_z),
                     names(env.in)[1:sum(grepl("bio", names(env.in)))])
  } else {
    names(vars) <- c("(Intercept)", "size", 
                     names(env.in)[1:sum(grepl("bio", names(env.in)))])
  }
  if(clim_sq) {
    covariates <- paste0("~ ", paste(names(vars)[-1], collapse=" + "))
  } else {
    covariates <- paste0("~ ", paste(names(vars[-grep("sq", names(vars))])[-1],
                                     collapse=" + "))
  }
  
  # fit vital rate regressions
  ## storage objects
  params <- list()
  vital.par <- map(1:4, ~c(vars))
  vital.reg <- vector("list", 4)
  names(vital.par) <- names(vital.reg) <- c("surv", "growth", "flower", "seeds")
  ## datasets
  plot.df <- sp.ls[[sp]] %>% 
    filter(habitat==ifelse(grepl("mustard", sp), 1, 0)) %>%
    select(wplot, size, sizeNext, surv, fec1, fec2, fec3, flowering) %>%
    mutate(size2=size^2, size3=size^3) %>%
    left_join(., X.df, by="wplot")
  all.df <- read.csv(dir("data/PNAS_2017", sp, full.names=T)) %>%
    mutate(size2=size^2, size3=size^3)
  ## 1. survival: logit(s) ~ size + env
  ## 2. growth: sizeNext ~ size + env
  ## 3. flowering: logit(fl) ~ size (+ env for mustards)
  ## 4. seeds: log(seeds) ~ size (+ env for mustards)
  vital.reg[[1]] <- glm(as.formula(paste0("surv", covariates)), 
                        data=filter(plot.df, !is.na(surv)), family="binomial")
  vital.reg[[2]] <- lm(as.formula(paste0("sizeNext", covariates)), 
                       data=filter(plot.df, !is.na(size) & !is.na(sizeNext)))
  if(grepl("mustard", sp)) {
    ## these are bienniel species
    ## need to modify IPM construction so P applies in first year, F in second
    vital.reg[[3]] <- glm(as.formula(paste0("flowering", covariates)), 
                          data=filter(plot.df, !is.na(flowering) & !is.na(size)), 
                          family="binomial")
    vital.reg[[4]] <- glm(as.formula(paste0("fec1", covariates)), 
                          data=filter(plot.df, !is.na(fec1) & !is.na(size)), 
                          family="poisson")
  } else {
    z_form <- ifelse(n_z==1, "~ size",
                     paste0("~ size + ", paste0("size", 2:n_z, collapse=" + ")))
    vital.reg[[3]] <- glm(as.formula(paste0("flowering", z_form)), 
                          data=filter(all.df, !is.na(flowering)), 
                          family="binomial")
    vital.reg[[4]] <- glm(as.formula(paste0("fec1", z_form)), 
                          data=filter(all.df, !is.na(fec1)), 
                          family="poisson")
  }
  
  # store parameter estimates
  for(i in seq_along(vital.reg)) {
    vital.par[[i]][names(coef(vital.reg[[i]]))] <- coef(vital.reg[[i]])
    vital.par[[i]][is.na(vital.par[[i]])] <- 0
  }
  ## vital rate regressions
  params$s_z <- vital.par[[1]][1:(n_z+1)]
  params$s_x <- vital.par[[1]][(n_z+2):length(vital.par[[1]])]
  params$g_z <- vital.par[[2]][1:(n_z+1)]
  params$g_x <- vital.par[[2]][(n_z+2):length(vital.par[[2]])]
  params$g_sig <- summary(vital.reg[[2]])$sigma
  params$fl_z <- vital.par[[3]][1:(n_z+1)]
  params$fl_x <- vital.par[[3]][(n_z+2):length(vital.par[[3]])]
  params$seed_z <- vital.par[[4]][1:(n_z+1)]
  params$seed_x <- vital.par[[4]][(n_z+2):length(vital.par[[4]])]
  ## recruit size distribution
  rcr_dist <- filter(all.df, Year.planted==Year.size & is.na(flowering))$size
  params$rcr_z <- c(mean(rcr_dist, na.rm=T), sd(rcr_dist, na.rm=T))
  ## allowable size range
  params$z.rng <- with(all.df, range(c(size, sizeNext), na.rm=TRUE))*c(.75,1.25)
  ## probability of direct recruitment (i.e., germination)
  params$rcr_dir <- params$rcr_SB <- mean(all.df$fec2, na.rm=T)
  ## probability of establishment given germination
  params$p_est <- mean(all.df$fec3, na.rm=T)
  ## seed bank survival
  params$s_SB <- ifelse(grepl("mustard", sp), 0.8, 0.9)
  
  return(p=params)
}

