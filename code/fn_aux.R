# Auxilliary functions
# Comparison of SDM approaches
# Tim Szewczyk


##-- antilogit
#' Take the antilogit of the input
#' @param x Scalar, vector, or matrix of values
antilogit <- function (x) {
  exp(x)/(1 + exp(x))
}



##-- logit
#' Take the logit of the input
#' @param x Scalar, vector, or matrix of probabilities
logit <- function (x) {
  log(x/(1-x))
}



##-- generate landscape 
#' Assemble the necessary landscape files. This aggregates NLCD categories and
#' extracts the specified bioclimatic variables, returning one full-grid
#' dataframe with variables scaled, one full-grid dataframe with raw values, one
#' in-bound dataframe with scaled values, and an index for the scaling.
#' @param f Landscape grid file (e.g., ENF_5km.csv)
#' @param nlcd_agg Dataframe with NLCD aggregation scheme
#' @param x_max \code{Inf} Maximum row in grid (Inf = full-scale)
#' @param x_min \code{0} Minimum row in grid (0 = full-scale)
#' @param y_max \code{Inf} Maximum column in grid (Inf = full-scale)
#' @param y_min \code{0} Minimum column in grid (0 = full-scale)
#' @param clim_X Column names for bioclimatic variables to include. Defaults to 
#' all 19 variables
build_landscape <- function(f, nlcd_agg, x_min=0, x_max=Inf, y_min=0, y_max=Inf,
                            clim_X=paste0("bio10_", c(1:19, "prMay"))) {
  library(tidyverse)
  # load GIS data & create x-y columns for landscape grid
  f.df <- suppressMessages(read_csv(f)) %>% 
    na.omit %>%
    mutate(x=as.integer(factor(.$long)),
           y=as.integer(factor(.$lat, levels=rev(levels(factor(.$lat))))),
           x_y=paste(x, y, sep="_"))
  lc.cat <- unique(nlcd_agg$agg)
  n_lc <- length(lc.cat)
  n_clim <- length(clim_X)
  # aggregate NLCD categories as detailed in nlcd_agg
  nlcd_agg$orig <- paste0("nlcd_", nlcd_agg$orig)
  agg.mx <- matrix(nrow=nrow(f.df), ncol=n_lc)
  colnames(agg.mx) <- lc.cat
  for(i in 1:n_lc) {
    agg.mx[,i] <- rowSums(f.df[, with(nlcd_agg, orig[agg==lc.cat[i]])])
  }
  # assemble specified variables
  l.df <- cbind(f.df[, c("long", "lat", "x", "y", "x_y", "prSamp", clim_X)], agg.mx) %>%
    filter(x>=x_min & x<=x_max & y>=y_min & y<=y_max)
  # center & scale covariates, store center & scale
  l.scale <- select(l.df, -(1:6)) %>% scale
  scale.i <- cbind(sc_mn=attributes(l.scale)$`scaled:center`,
                   sc_sd=attributes(l.scale)$`scaled:scale`)
  rownames(scale.i) <- colnames(l.scale)
  # establish rectangular grid with x=1:ncol, y=1:nrow
  rct <- as_tibble(expand.grid(x=1:max(l.df$x), y=1:max(l.df$y))) %>%
    mutate(x_y=paste(x, y, sep="_")) 
  match_id <- match(rct$x_y, l.df$x_y)
  # pair scaled environmental variables with rectangular grid
  l.rct <- l.scale[match_id, rep(1:ncol(l.scale), rep(2:1, c(n_clim, n_lc)))]
  l.rct[,2*(1:n_clim)] <- l.rct[,2*(1:n_clim)]^2
  colnames(l.rct)[2*(1:n_clim)] <- paste0(colnames(l.rct)[2*(1:n_clim)], "_sq")
  env.rct <- cbind(l.rct, rct) %>%
    mutate(inbd=!is.na(match(.$x_y, l.df$x_y)),
           lat=l.df$lat[match_id],
           lon=l.df$long[match_id],
           prSamp=l.df$prSamp[match_id]) %>%
    mutate(id=row_number(), 
           id.in=min_rank(na_if(inbd*id, 0)))
  # env.rct[is.na(env.rct)] <- 0
  # pair unscaled environmental variables (required for dispersal probabilities)
  env.rct.unscaled <- cbind(env.rct[,-(1:(n_lc+n_clim*2))], 
                            l.df[match_id,-(1:5)])
  # subset inbound cells
  env.in <- filter(env.rct, inbd)
  # store input arguments
  env.args <- list(f=f, clim_X=clim_X, 
                   nlcd_agg=mutate(nlcd_agg, orig=str_remove(orig, "nlcd_")), 
                   x_min=x_min, x_max=x_max, y_min=y_min, y_max=y_max)
  return(list(env.rct=env.rct, env.rct.unscaled=env.rct.unscaled,
              env.in=env.in, scale.i=scale.i, env.args=env.args))
}



##-- create design matrix from vector of individual sizes
#' From a vector of sizes \code{z.vec}, generate a design matrix with a column 
#' 1's, a column of \code{z.vec}, a column of \code{z.vec^2}, ..., a column of 
#' \code{z.vec^n_z}
#' @param z.vec Vector of individual sizes, with one value for each individual 
#' in the population
#' @param n_z Largest exponent desired for \code{z.vec}
z_pow <- function(z.vec, n_z) {
  if(n_z==1) {
    return(matrix(1, ncol=1, nrow=length(z.vec)))
  } else {
    z <- matrix(z.vec, nrow=length(z.vec), ncol=n_z-1)
    for(i in 1:(n_z-1)) z[,i] <- z[,i]^i
    z <- cbind(1, z)
    return(z)
  }
}




##-- aggregate multiple demographic CA simulations
#' Aggregate output from a list of demographic cellular automata simulations 
#' into a list of arrays suitable for summarizing across simulations. 
#' @param sim.ls A list of simulations where each element of the list was 
#' generated by gbPopMod::run_sim()
#' @param y.ad Maximum age (year) of maturity in CA-d simulations; equivalent to
#' \code{max(CA_params$m)}; \code{?gbPopMod::set_g_p}
#' @return List of arrays with elements for P = adult presence, B = seed 
#' abundance, nSd = number of seeds produced, nSdStay = number of seeds 
#' remaining in source cell, D = number of immigrant seeds, N_tot = total 
#' non-seed abundance, N_ad = adult abundance, N_rcr = number of seedlings. 
#' Arrays include dimensions for grid cell, time, and simulation
aggregate_CAd_simulations <- function(sim.ls, y.ad) {
  library(tidyverse)
  l <- list(P=map(sim.ls, ~.$N[,,y.ad]>0),
            B=map(sim.ls, ~.$B),
            nSd=map(sim.ls, ~.$nSd),
            nSdStay=map(sim.ls, ~.$nSdStay),
            D=map(sim.ls, ~.$D),
            N_tot=map(sim.ls, ~apply(.$N, 1:2, sum)),
            N_ad=map(sim.ls, ~.$N[,,y.ad]),
            N_rcr=map(sim.ls, ~.$N[,,1]))
  return(map(l, simplify2array))
}



##-- aggregate multiple individual CA simulations
#' Aggregate output from a list of individual-based cellular automata 
#' simulations into a list of arrays suitable for summarizing across simulations. 
#' @param sim.ls A list of simulations where each element of the list was 
#' generated by simulate_data()
#' @param tmax Maximum time step in simulations
#' @return List of arrays with elements for P = adult presence in final year, B = seed 
#' abundance, nSd = number of seeds produced, D = number of immigrant seeds, 
#' p_est = establishment probability, N_tot = total non-seed abundance including
#' new recruits, N_surv = abundance of individuals >1 year, N_rcr = number of 
#' seedlings. Arrays include dimensions for grid cell, time, and simulation
aggregate_CAi_simulations <- function(sim.ls, tmax) {
  library(tidyverse)
  l <- list(P=map(sim.ls, ~map_dbl(.$d, ~sum(.$surv[.$yr==tmax], na.rm=T))>0),
            B=map(sim.ls, ~.$B),
            nSd=map(sim.ls, ~.$nSd),
            D=map(sim.ls, ~.$D),
            p_est=map(sim.ls, ~.$p_est.i),
            N_tot=map(sim.ls, 
                      ~map_dbl(.$d, ~sum(!is.na(.$sizeNext[.$yr==tmax])))),
            N_surv=map(sim.ls, 
                       ~map_dbl(.$d, ~sum(.$surv[.$yr==tmax], na.rm=T))),
            N_rcr=map(sim.ls, ~map_dbl(.$d, ~sum(is.na(.$size[.$yr==tmax])))))
  return(map(l, simplify2array))
}



##-- calculate means across multiple samples for demographic CA simulations
#' Summarize demographic CA simulations across multiple samples.
#' @param CA.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from aggregate_CAd_simulations()
#' @param in.id Vector of rectangular id's for inbound cells (i.e., lam.df$id)
#' @return List with elements for prP = probability of presence, B.mn = mean
#' seed bank abundance, nSd.mn = mean number of seeds produced, nSdStay.mn = 
#' mean number of local seeds deposited, D.mn = mean number of immigrant seeds,
#' N_tot.mn = mean total abundance, N_ad.mn = mean adult abundance, N_rcr.mn = 
#' mean seedling abundance
summarize_CAd_samples <- function(CA.f, in.id) {
  Sa <- list(P=map(CA.f, ~.$P),
             B=map(CA.f, ~.$B),
             nSd=map(CA.f, ~.$nSd),
             nSdStay=map(CA.f, ~.$nSdStay),
             D=map(CA.f, ~.$D),
             N_tot=map(CA.f, ~.$N_tot),
             N_ad=map(CA.f, ~.$N_ad),
             N_rcr=map(CA.f, ~.$N_rcr)) %>%
    map(simplify2array)
  return(list(prP=apply(Sa$P[in.id,,,], 1:2, mean, na.rm=T),
              B.mn=apply(Sa$B[in.id,,,], 1:2, mean, na.rm=T),
              nSd.mn=apply(Sa$nSd[in.id,,,], 1:2, mean, na.rm=T),
              nSdStay.mn=apply(Sa$nSdStay[in.id,,,], 1:2, mean, na.rm=T),
              D.mn=apply(Sa$D[in.id,,,], 1:2, mean, na.rm=T),
              N_tot.mn=apply(Sa$N_tot[in.id,,,], 1:2, mean, na.rm=T),
              N_ad.mn=apply(Sa$N_ad[in.id,,,], 1:2, mean, na.rm=T),
              N_ad.sd=apply(Sa$N_ad[in.id,,,], 1:2, sd, na.rm=T),
              N_ad.025=apply(Sa$N_ad[in.id,,,], 1:2, quantile, probs=0.025, na.rm=T),
              N_ad.25=apply(Sa$N_ad[in.id,,,], 1:2, quantile, probs=0.25, na.rm=T),
              N_ad.75=apply(Sa$N_ad[in.id,,,], 1:2, quantile, probs=0.75, na.rm=T),
              N_ad.975=apply(Sa$N_ad[in.id,,,], 1:2, quantile, probs=0.975, na.rm=T),
              N_rcr.mn=apply(Sa$N_rcr[in.id,,,], 1:2, mean, na.rm=T)))
}



##-- calculate means across multiple samples for IPM & individual CA simulations
#' Summarize IPM and individual CA simulations across multiple samples. As 
#' throughout, 'U' refers to the theoretical IPM output and 'S' refers to the
#' individual CA simulations.
#' @param U.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from fill_IPM_matrices()
#' @param S.f List of fitted distributions, with one element per sample, and 
#' where each element is the output from aggregate_CAi_simulations()
#' @return List with elements for 1: Uf, containing {prP = probability of 
#' lambda>1, lam.mn = mean(lambda), IPM.mn = mean(IPM matrix), P.mn = 
#' mean(P matrix), and F.mn = mean(F matrix)}, and 2: Sf, containing prP = 
#' probability of presence, B.mn = mean seed bank abundance, nSd.mn = mean 
#' number of seeds produced, D.mn = mean number of immigrant seeds, p_est.mn = 
#' mean establishment probability, N_tot.mn = mean total abundance, N_surv.mn = 
#' mean abundance of individuals >1 year, N_rcr.mn = mean seedling abundance
summarize_IPM_CAi_samples <- function(U.f=NULL, S.f=NULL) {
  if(!is.null(U.f)) {
    # Ua <- list(IPMs=map(U.f, ~.$IPMs),
    #            lam=map(U.f, ~.$lambda)) %>% 
    #   map(simplify2array)
    # Uf.pa <- Ua$lam>=1
    # Uf <- list(prP=apply(Uf.pa, 1, mean),
    #            lam.mn=apply(Ua$lam, 1, mean),
    #            IPM.mn=apply(Ua$IPMs, 1:3, mean))
    Ua <- list(lam=map(U.f, ~.$lambda)) %>% 
      map(simplify2array)
    Uf.pa <- Ua$lam>=1
    # Uf <- list(prP=apply(Uf.pa, 1, mean),
    #            lam.mn=apply(Ua$lam, 1, mean))
    Uf <- Ua
  } else {
    Uf <- NULL
    Uf.pa <- NULL
  }
  if(!is.null(S.f)) {
    Sa <- list(P=map(S.f, ~.$P),
               B=map(S.f, ~.$B),
               nSd=map(S.f, ~.$nSd),
               D=map(S.f, ~.$D),
               p_est=map(S.f, ~.$p_est),
               N_tot=map(S.f, ~.$N_tot),
               N_surv=map(S.f, ~.$N_surv),
               N_rcr=map(S.f, ~.$N_rcr)) %>%
      map(simplify2array)
    Sf <- list(prP=apply(Sa$P, 1, mean),
               B.mn=apply(Sa$B, 1:2, mean),
               nSd.mn=apply(Sa$nSd, 1:2, mean),
               D.mn=apply(Sa$D, 1:2, mean),
               p_est.mn=apply(Sa$p_est, 1:2, mean),
               N_tot.mn=apply(Sa$N_tot, 1, mean),
               N_surv.mn=apply(Sa$N_surv, 1, mean),
               N_surv.sd=apply(Sa$N_surv, 1, sd),
               N_surv.025=apply(Sa$N_surv, 1, quantile, probs=0.025),
               N_surv.25=apply(Sa$N_surv, 1, quantile, probs=0.25),
               N_surv.75=apply(Sa$N_surv, 1, quantile, probs=0.75),
               N_surv.975=apply(Sa$N_surv, 1, quantile, probs=0.975),
               N_rcr.mn=apply(Sa$N_rcr, 1, mean)) 
    Sf.pa <- Sa$P[,1,]
  } else {
    Sf <- NULL
    Sf.pa <- NULL
  }
  return(list(Uf=Uf, Sf=Sf, Uf.pa=Uf.pa, Sf.pa=Sf.pa))
}



##-- extract SDM sampling & modeling issues from file names
#' Extract the SDM method and the modeling issue from the file names
#' @param f Vector of file names for the predicted distributions generated in 
#' 3_fitModels.R, with the structure of 'P_SDMtype_Issue.rds'
#' @param prefix Character prefix denoting file content type (e.g., 'P')
#' @return List with an element for each file, where each element is a vector
#' of c("SDMtype", "Issue")
extract_SDM_details <- function(f, prefix) {
  library(stringr)
  str_split(str_remove(str_split(f, paste0(prefix, "_"), Inf, T)[,2], 
                       ".rds"), "_")
}



##-- fit vital rate regressions for PNAS 2017 species
#' For a specified species, fit vital rate regressions using the defined 
#' climatic variables and maximum size exponent. 
#' @param sp \code{"barberry"} Either 'barberry', 'garlic_mustard'
#' @param f Landscape grid file (e.g., ENF_5km.csv)
#' @param nlcd_agg Dataframe with NLCD aggregation scheme
#' @param clim_X \code{"bio10_1"} Column names for bioclimatic variables to
#'  include
#' @param clim_sq \code{TRUE} Include square of each clim_X?
#' @param n_z \code{1} Maximum exponent to raise the size distribution to
#' @param habitat \code{3} Local habitat conditions. Integer from 1-4, where
#'   1 = poor, 2 = mean(unfavorable), 3 = mean(favorable), 4 = optimal
#' @return List of parameters for all vital rate regressions, in addition to
#' rcr_z, z.rng, rcr_dir, p_est, and s_SB
fit_PNAS_species <- function(sp="barberry", f, nlcd_agg, clim_X="bio10_1", 
                             clim_sq=TRUE, n_z=1, habitat=3,
                             x_min=0, x_max=Inf, y_min=0, y_max=Inf) {
  ##-- Set up
  library(tidyverse); library(magrittr); library(here); library(MuMIn)
  walk(paste0("code/fn_", c("IPM", "aux", "sim"), ".R"), ~source(here(.)))
  plot_i <- suppressMessages(read_csv("data/PNAS_2017/plot_coords.csv"))
  env.in <- build_landscape(f=f, nlcd_agg=nlcd_agg, clim_X=clim_X, 
                            x_min=x_min, x_max=x_max, 
                            y_min=y_min, y_max=y_max)$env.in
  n.cell <- sum(env.in$inbd)
  sp.ls <- readRDS("data/PNAS_2017/species_data_list.rds")
  
  # extract covariates for cells containing PNAS plots
  radius <- mean(diff(sort(unique(env.in$lat))))/2
  plot_i$id.in <- NA
  for(i in 1:nrow(plot_i)) {
    plot_i$id.in[i] <- env.in$id.in[abs(env.in$lon-plot_i$lon[i]) < radius & 
                                          abs(env.in$lat-plot_i$lat[i]) < radius]
  }
  X.df <- right_join(env.in, plot_i, by="id.in")
  vars <- rep(0, 1+n_z+sum(grepl("bio", names(env.in))))
  if(n_z>1) {
    names(vars) <- c("(Intercept)", "size", paste0("size", 2:n_z),
                     names(env.in)[1:sum(grepl("bio", names(env.in)))])
  } else {
    names(vars) <- c("(Intercept)", "size", 
                     names(env.in)[1:sum(grepl("bio", names(env.in)))])
  }
  if(clim_sq) {
    covariates <- paste0("~ ", paste(names(vars)[-1], collapse=" + "))
  } else {
    covariates <- paste0("~ ", paste(names(vars[-grep("sq", names(vars))])[-1],
                                     collapse=" + "))
  }
  
  # fit vital rate regressions
  ## storage objects
  params <- list()
  vital.par <- map(1:5, ~c(vars))
  vital.reg <- vector("list", length(vital.par))
  names(vital.par) <- names(vital.reg) <- c("surv", "growth", 
                                            "flower", "seeds", "germ")
  ## datasets
  plot.df <- sp.ls[[sp]] %>% 
    filter(habitat!=ifelse(grepl("mustard", sp), 2, 1)) %>%
    select(wplot, size, sizeNext, surv, fec1, fec2, fec3, flowering,
           n.germ.0, n.germ.1, Ph.ave, N, PAR, light) %>%
    mutate(size2=size^2, size3=size^3) %>%
    left_join(., X.df, by="wplot")
  all.df <- read.csv(dir("data/PNAS_2017", paste0(sp, "_data"), full.names=T)) %>%
    mutate(size2=size^2, size3=size^3) %>%
    left_join(., X.df, by="wplot")
  hab.mns <- all.df %>% group_by(habitat) %>% 
    summarise(PAR=mean(PAR, na.rm=T), 
              pH=mean(Ph.ave, na.rm=T),
              N=mean(N, na.rm=T),
              light=mean(light, na.rm=T))
  hab.opt <- sign(hab.mns) %>% mutate_at(-1, ~.*1.95)
  ## 1. survival: logit(s) ~ size + env
  ## 2. growth: sizeNext ~ size + env
  ## 3. flowering: logit(fl) ~ size (+ env for mustards)
  ## 4. seeds: log(seeds) ~ size (+ env for mustards)
  ## 5. germination: logit(p.germ) ~ env
  vital.reg[[1]] <- glm(as.formula(paste0("surv", covariates, 
                                          "+ light + Ph.ave + N")), 
                        data=filter(plot.df, !is.na(surv)), family="binomial")
  vital.reg[[2]] <- lm(as.formula(paste0("sizeNext", covariates, 
                                         "+ light + Ph.ave + N")), 
                       data=filter(plot.df, !is.na(size) & !is.na(sizeNext)))
  if(grepl("mustard", sp)) {
    vital.reg[[3]] <- glm(as.formula(paste0("flowering", covariates)), 
                          data=filter(plot.df, !is.na(flowering) & !is.na(size)), 
                          family="binomial")
    vital.reg[[4]] <- glm(as.formula(paste0("fec1", covariates, "+ PAR + Ph.ave")), 
                          data=filter(plot.df, !is.na(fec1) & !is.na(size)), 
                          family="poisson")
  } else {
    z_form <- ifelse(n_z==1, "~ size",
                     paste0("~ size + ", paste0("size", 2:n_z, collapse=" + ")))
    vital.reg[[3]] <- glm(as.formula(paste0("flowering", z_form)), 
                          data=filter(all.df, !is.na(flowering)), 
                          family="binomial")
    vital.reg[[4]] <- glm(as.formula(paste0("fec1", z_form)), 
                          data=filter(all.df, !is.na(fec1)), 
                          family="poisson")
  }
  vital.reg[[5]] <- glm(as.formula(paste0("cbind(n.germ.1, n.germ.0)",
                                          str_remove(covariates, "size.\\+"), 
                                          " + Ph.ave + light")),
                        data=filter(all.df, !is.na(fec2)), family="binomial")
  
  # store parameter estimates
  vital.coef <- map(vital.reg, coef)
  if(habitat==1) hab_eff <- hab.opt[ifelse(grepl("mustard", sp), 2, 1),-1]
  if(habitat==2) hab_eff <- hab.mns[ifelse(grepl("mustard", sp), 2, 1),-1]
  if(habitat==3) hab_eff <- hab.mns[ifelse(grepl("mustard", sp), 1, 2),-1]
  if(habitat==4) hab_eff <- hab.opt[ifelse(grepl("mustard", sp), 1, 2),-1]
  for(i in seq_along(vital.reg)) {
    vital.coef[[i]][1] <- vital.coef[[i]][1] + 
      sum(vital.coef[[i]][c("PAR", "Ph.ave", "N", "light")] * hab_eff, na.rm=T)
    vital.coef[[i]] <- vital.coef[[i]][!names(vital.coef[[i]]) %in% 
                                                c("PAR", "Ph.ave", "N", "light")]
    vital.par[[i]][names(vital.coef[[i]])] <- vital.coef[[i]]
    vital.par[[i]][is.na(vital.par[[i]])] <- 0
  }
  ## vital rate regressions
  params$s_z <- vital.par[[1]][1:(n_z+1)]
  params$s_x <- vital.par[[1]][(n_z+2):length(vital.par[[1]])]
  params$g_z <- vital.par[[2]][1:(n_z+1)]
  params$g_x <- vital.par[[2]][(n_z+2):length(vital.par[[2]])]
  params$g_sig <- summary(vital.reg[[2]])$sigma
  params$fl_z <- vital.par[[3]][1:(n_z+1)]
  params$fl_x <- vital.par[[3]][(n_z+2):length(vital.par[[3]])]
  params$seed_z <- vital.par[[4]][1:(n_z+1)]
  params$seed_x <- vital.par[[4]][(n_z+2):length(vital.par[[4]])]
  params$germ_x <- vital.par[[5]][-(1+(1:n_z))]
  ## recruit size distribution
  rcr_dist <- filter(all.df, Year.planted==Year.size & is.na(flowering))$size
  params$rcr_z <- c(mean(rcr_dist, na.rm=T), sd(rcr_dist, na.rm=T))
  ## allowable size range
  params$z.rng <- with(all.df, range(c(size, sizeNext), na.rm=TRUE))
  ## probability of direct recruitment (i.e., germination)
  params$rcr_dir <- params$rcr_SB <- mean(all.df$fec2, na.rm=T)
  ## probability of establishment given germination
  params$p_est <- mean(all.df$fec3, na.rm=T)
  ## seed bank survival
  params$s_SB <- ifelse(grepl("mustard", sp), 0.85, 0.2)
  ## maximum per capita seed production
  params$seed_max <- max(all.df$fec1, na.rm=T)*2
  
  return(p=params)
}



##-- calculate the true skill statistic (TSS)
#' Given predicted presence/absence and true presence/absence, calculate the
#' True Skill Statistic (TSS) as 'sensitivity + specificity - 1' = (correctly 
#' predicted presences)/(total presences) + (correctly predicted absences)/
#' (total absences) - 1
#' @param S.pa Logical vector of true presences and absences
#' @param P.pa Logical vector of predicted presences and absences
#' @return Scalar TSS score
calc_TSS <- function(S.pa, P.pa) {
  sensitivity <- sum(S.pa & P.pa)/sum(S.pa)
  specificity <- sum(!S.pa & !P.pa)/sum(!S.pa)
  return(list(sensitivity=sensitivity, 
              specificity=specificity,
              TSS=sensitivity + specificity - 1))
}



##-- plot predicted regression lines for IPM & CAd
#' Compare vital rate regression lines for fitted models vs. true values
#' @param p True parameters
#' @param sdm.diag List of diagnostic outputs
#' @param pars Parameter to plot
#' @param par.v Indexes of parameters
#' @param X Vector for the x-axis
#' @param X.mx Design matrix
#' @param cols Color for each element in \code{ipm.diag}
#' @param xlab x-axis label
#' @param ylab y-axis label
#' @param xlim x-axis limits
#' @param ylim y-axis limits
plot_sdm_reg <- function(p, sdm.diag, pars, par.v, X, X.mx, cols, 
                         xlab, ylab, xlim, ylim) {
  
  # plot structure
  plot(NA, NA, xlab=xlab, ylab=ylab, ylim=ylim, xlim=xlim, cex.lab=1.5)
  
  if(grepl("s_|fl_|germ_|p.f|s.M|s.N", pars) | pars=="g.D") {
    # antilogit
    for(i in seq_along(sdm.diag)) {
      walk(sdm.diag[[i]], 
           ~lines(X, antilogit(X.mx %*% .[[pars]][par.v]), col=cols[i]))
    }
    if(!is.null(p[[pars]])) {
      lines(X, antilogit(X.mx %*% p[[pars]][par.v]), lwd=2, lty=3)
    }
  } else if(grepl("seed_|K|mu", pars)) {
    # exponential
    for(i in seq_along(sdm.diag)) {
      walk(sdm.diag[[i]], 
           ~lines(X, exp(X.mx %*% .[[pars]][par.v]), col=cols[i]))
    }
    if(!is.null(p[[pars]])) {
      lines(X, exp(X.mx %*% p[[pars]][par.v]), lwd=2, lty=3)
    }
  } else if(grepl("g_", pars)) {
    # linear
    for(i in seq_along(sdm.diag)) {
      walk(sdm.diag[[i]], ~lines(X, X.mx %*% .[[pars]][par.v], col=cols[i]))
    }
    if(!is.null(p[[pars]])) {
      lines(X, X.mx %*% p[[pars]][par.v], lwd=2, lty=3)
    }
  } else {
    # recruit size distribution
    for(i in seq_along(sdm.diag)) {
      walk(sdm.diag[[i]], ~curve(dnorm(x, .[[pars]][1], .[[pars]][2]), add=T, 
                                 from=xlim[1], to=xlim[2], col=cols[i]))
    }
    curve(dnorm(x, p[[pars]][1], p[[pars]][2]), from=xlim[1], to=xlim[2], 
          add=T, lwd=2, lty=3)
  }
}





#' @title Layout panels in a grid with nested strips
#'
#' @description \code{facet_nest()} form a matrix of panels defined by row and
#'   column faceting variables and nests grouped facets.
#'
#' @param
#' rows,cols,scales,space,shrink,labeller,as.table,switch,drop,margins,facets
#' see \code{\link[ggplot2]{facet_grid}}
#' @param nest_line a \code{logical} vector of length 1, indicating whether to
#'   draw a nesting line to indicate the nesting of variables.
#' @param resect  a \code{unit} vector of length 1, indicating how much the
#'   nesting line should be shortened.
#' @param bleed a \code{logical} vector of length 1, indicating wether merging
#'   of lower-level variables is allowed when the higher-level variables are
#'   seperate. See details.
#'
#' @details Unlike \code{facet_grid()}, this function only automatically expands
#'   missing variables when they have no variables in that direction, to allow
#'   for unnested variables. It still requires at least one layer to have all
#'   faceting variables.
#'
#'   Hierarchies are inferred from the order of variables supplied to
#'   \code{rows} or \code{cols}. The first variable is interpreted to be the
#'   outermost variable, while the last variable is interpreted to be the
#'   innermost variable. They display order is always such that the outermost
#'   variable is placed the furthest away from the panels. Strips are
#'   automatically grouped when they span a nested variable.
#'
#'   The \code{bleed} argument controls wether lower-level variables are allowed
#'   to be merged when higher-level are different, i.e. they can bleed over
#'   hierarchies. Suppose the \code{facet_grid()} behaviour would be the
#'   following:
#'
#'   \code{[_1_][_2_][_2_]} \cr \code{[_3_][_3_][_4_]}
#'
#'   In such case, the default \code{bleed = FALSE} argument would result in the
#'   following:
#'
#'   \code{[_1_][___2____]} \cr \code{[_3_][_3_][_4_]}
#'
#'   Whereas \code{bleed = TRUE} would allow the following:
#'
#'   \code{[_1_][___2____]} \cr \code{[___3____][_4_]}
#'
#' @export
#'
#' @seealso See \code{\link[ggplot2]{facet_grid}} for descriptions of the
#'   original arguments. See \code{\link[grid]{unit}} for the construction of a
#'   \code{unit} vector.
#'
#' @examples
#' df <- iris
#' df$nester <- ifelse(df$Species == "setosa",
#'                     "Short Leaves",
#'                     "Long Leaves")
#'
#' ggplot(df, aes(Sepal.Length, Petal.Length)) +
#'   geom_point() +
#'   facet_nested(~ nester + Species)
#'
#' @import ggplot2
facet_nested <- function(rows = NULL, cols = NULL, scales = "fixed", space = "fixed",
                         shrink = TRUE, labeller = "label_value", as.table = TRUE,
                         switch = NULL, drop = TRUE, margins = FALSE, facets = NULL,
                         nest_line = FALSE, resect = unit(0, "mm"), bleed = FALSE)
{
  if (!is.null(facets)) {
    rows <- facets
  }
  if (is.logical(cols)) {
    margins <- cols
    cols <- NULL
  }
  scales <- match.arg(scales, c("fixed", "free_x", "free_y", "free"))
  free <- list(x = any(scales %in% c("free_x", "free")),
               y = any(scales %in% c("free_y", "free")))
  
  space <- match.arg(space, c("fixed","free_x","free_y","free"))
  space_free <- list(x = any(space %in% c("free_x", "free")),
                     y = any(space %in% c("free_y", "free")))
  
  if (!is.null(switch) && !switch %in% c("both","x","y")) {
    stop("switch must be either 'both', 'x', or 'y'", call. = FALSE)
  }
  
  facets_list <- ggplot2:::grid_as_facets_list(rows, cols)
  n <- length(facets_list)
  if (n > 2L) {
    stop("A grid facet specification can't have more than two dimensions",
         .call = FALSE)
  }
  if (n == 1L) {
    rows <- quos()
    cols <- facets_list[[1]]
  } else {
    rows <- facets_list[[1]]
    cols <- facets_list[[2]]
  }
  labeller <- ggplot2:::check_labeller(labeller)
  ggproto(NULL, FacetNested, shrink = shrink,
          params = list(
            rows = rows,
            cols = cols,
            margins = margins,
            free = free,
            space_free = space_free,
            labeller = labeller,
            as.table = as.table,
            switch = switch,
            drop = drop,
            nest_line = nest_line,
            resect = resect,
            bleed = bleed
          ))
}

#' @rdname facet_nested
#' @format NULL
#' @usage NULL
#' @export
FacetNested <- ggplot2::ggproto(
  "FacetNested", ggplot2::
    FacetGrid,
  map_data = function(data, layout, params) {
    # Handle empty data
    if (ggplot2:::empty(data)) {
      return(cbind(data, PANEL = integer(0)))
    }
    # Setup variables
    rows <- params$rows
    cols <- params$cols
    
    vars <- c(names(rows), names(cols))
    margin_vars <- list(intersect(names(rows), names(data)),
                        intersect(names(cols), names(data)))
    
    # Add variables
    data <- reshape2::add_margins(data, margin_vars, params$margins)
    facet_vals <- ggplot2:::eval_facets(c(rows, cols), data, params$plot$env)
    
    # Only set as missing if it has no variable in that direction
    missing_facets <- character(0)
    if (!any(names(rows) %in% names(facet_vals))){
      missing_facets <- c(missing_facets, setdiff(names(rows), names(facet_vals)))
    }
    if (!any(names(cols) %in% names(facet_vals))){
      missing_facets <- c(missing_facets, setdiff(names(cols), names(facet_vals)))
    }
    
    # Fill in missing values
    if (length(missing_facets) > 0) {
      to_add <- unique(layout[missing_facets])
      data_rep <- rep.int(1:nrow(data), nrow(to_add))
      facet_rep <- rep(1:nrow(to_add), each = nrow(data))
      data <- plyr::unrowname(data[data_rep, , drop = FALSE])
      facet_vals <- plyr::unrowname(
        cbind(facet_vals[data_rep, , drop = FALSE],
              to_add[facet_rep, , drop = FALSE])
      )
    }
    
    # Match columns to facets
    if (nrow(facet_vals) == 0) {
      data$PANEL <- NO_PANEL
    } else {
      facet_vals[] <- lapply(facet_vals[], as.factor)
      facet_vals[] <- lapply(facet_vals[], addNA, ifany = TRUE)
      keys <- plyr::join.keys(facet_vals, layout, by = vars[vars %in% names(facet_vals)])
      data$PANEL <- layout$PANEL[match(keys$x, keys$y)]
    }
    data
  },
  compute_layout = function(data, params)
  {
    rows <- params$rows
    cols <- params$cols
    dups <- intersect(names(rows), names(cols))
    if (length(dups) > 0) {
      stop("Facetting variables can only appear in row or cols, not both.\n",
           "Problems: ", paste0(dups, collapse = "'"), call. = FALSE)
    }
    base_rows <- combine_nested_vars(data, params$plot_env, rows, drop = params$drop)
    if (!params$as.table) {
      rev_order <- function(x) factor(x, levels = rev(ggplot2:::ulevels(x)))
    }
    base_cols <- combine_nested_vars(data, params$plot_env, cols, drop = params$drop)
    base <- ggplot2:::df.grid(base_rows, base_cols)
    base <- reshape2::add_margins(base, list(names(rows), names(cols)), params$margins)
    base <- unique(base)
    panel <- plyr::id(base, drop = TRUE)
    panel <- factor(panel, levels = seq_len(attr(panel, "n")))
    rows <- if (!length(names(rows))) {
      1L
    } else {
      plyr::id(base[names(rows)], drop = TRUE)
    }
    cols <- if (!length(names(cols))) {
      1L
    } else {
      plyr::id(base[names(cols)], drop = TRUE)
    }
    panels <- data.frame(PANEL = panel, ROW = rows, COL = cols,
                         base, check.names = FALSE, stringsAsFactors = FALSE)
    panels <- panels[order(panels$PANEL), , drop = FALSE]
    rownames(panels) <- NULL
    panels$SCALE_X <- if (params$free$x) {
      panels$COL
    } else {
      1L
    }
    panels$SCALE_Y <- if (params$free$y) {
      panels$ROW
    } else {
      1L
    }
    panels
  },
  draw_panels = function(panels, layout, x_scales, y_scales, ranges, coord,
                         data, theme, params)
  {
    panel_table <- FacetGrid$draw_panels(panels, layout, x_scales, y_scales,
                                         ranges, coord, data, theme, params)
    
    # Setup strips
    col_vars  <- unique(layout[names(params$cols)])
    row_vars  <- unique(layout[names(params$rows)])
    attr(col_vars, "type")  <- "cols"
    attr(col_vars, "facet") <- "grid"
    attr(row_vars, "type")  <- "rows"
    attr(row_vars, "facet") <- "grid"
    
    # Build strips
    strips <- render_strips(col_vars, row_vars, params$labeller, theme)
    switch_x <- !is.null(params$switch) && params$switch %in% c("both", "x")
    switch_y <- !is.null(params$switch) && params$switch %in% c("both", "y")
    
    # Merging strips
    merge_cols <- apply(col_vars, 2, function(x) any(rle(x)$lengths > 1))
    merge_rows <- apply(row_vars, 2, function(x) any(rle(x)$lengths > 1))
    
    if (any(merge_cols)) {
      if (switch_x) {
        panel_table <- merge_strips(panel_table, strips$x$bottom,
                                    col_vars, switch_x, params, theme, "x")
      } else {
        panel_table <- merge_strips(panel_table, strips$x$top,
                                    col_vars, switch_x, params, theme, "x")
      }
    }
    
    if (any(merge_rows)) {
      if (switch_y) {
        panel_table <- merge_strips(panel_table, strips$y$left,
                                    row_vars, switch_y, params, theme, "y")
      } else {
        panel_table <- merge_strips(panel_table, strips$y$right,
                                    row_vars, switch_y, params, theme, "y")
      }
    }
    panel_table
  }
)

# Helper functions -----------------------------------------------

combine_nested_vars <- function(data, env = emptyenv(), vars = NULL, drop = TRUE) {
  if (length(vars) == 0)
    return(data.frame())
  values <- ggplot2:::compact(plyr::llply(data, ggplot2:::eval_facets, facets = vars,
                                          env = env))
  has_all <- unlist(lapply(values, length)) == length(vars)
  if (!any(has_all)) {
    missing <- lapply(values, function(x) setdiff(names(vars), names(x)))
    missing_txt <- vapply(missing, var_list, character(1))
    name <- c("Plot", paste0("Layer ", seq_len(length(data) - 1)))
    stop("At least one lyaer must contain all faceting variables: ",
         var_list(names(vars)), ".\n", paste0("* ", name, " is missing",
                                              missing_txt, collapse = "\n"),
         call. = FALSE)
  }
  base <- unique(plyr::ldply(values[has_all]))
  if (!drop) {
    base <- ggplot2:::unique_combs(base)
  }
  for (value in values[!has_all]) {
    if (ggplot2:::empty(value))
      next
    old <- base[setdiff(names(base), names(value))]
    new <- unique(value[intersect(names(base), names(value))])
    if (drop) {
      new <- ggplot2:::unique_combs(new)
    }
    old[setdiff(names(base), names(value))] <- rep("", nrow(old))
    base <- rbind(base, ggplot2:::df.grid(old, new))
  }
  if (ggplot2:::empty(base)) {
    stop("Facetting variables must have at least one value",
         call. = FALSE)
  }
  base
}


merge_strips <- function(panel_table, strip, vars, switch, params, theme, orient = c("x","y"))
{
  if (is.null(strip)) {
    return(panel_table)
  }
  n_levels <- nrow(strip[[1]]$layout)
  splitstrip <- lapply(seq_len(n_levels), function(i) {
    switch(orient,
           x = lapply(strip, function(x) x[i, ]),
           y = lapply(strip, function(x) x[, i]))
    
  })
  
  if (params$bleed) {
    merge <- apply(vars, 2, function(x) any(rle(x)$lengths > 1))
  } else {
    merge <- sapply(1:ncol(vars), function(i){
      x <- apply(subset.data.frame(vars, select = seq(i)), 1, paste0, collapse = "")
      return(any(rle(x)$lengths > 1))
    })
  }
  
  if (orient == "y" && !switch) {
    vars <- rev(vars)
    merge <- rev(merge)
  }
  if (orient == "x" && switch) {
    vars <- rev(vars)
    merge <- rev(merge)
    splitstrip <- rev(splitstrip)
  }
  
  sizes <- switch(orient,
                  x = do.call(unit.c, lapply(splitstrip, max_height)),
                  y = do.call(unit.c, lapply(splitstrip, max_width)))
  
  assign("panel_table", panel_table, 1)
  
  grabwhat <- switch(orient,
                     x = grepl("strip-t|strip-b", panel_table$layout$name),
                     y = grepl("strip-r|strip-l", panel_table$layout$name))
  
  pos_y <- unique(panel_table$layout$t[grabwhat])
  pos_x <- unique(panel_table$layout$l[grabwhat])
  panel_pos <- find_panel(panel_table)
  
  if (orient == "x") {
    nudge <- if (pos_y < panel_pos$t) -1 else -1
    panel_table <- panel_table[-pos_y,]
    panel_table <- gtable_add_rows(panel_table, sizes, pos_y + nudge)
    
  } else {
    nudge <- if (pos_x < panel_pos$l) -1 else 0
    panel_table <- panel_table[, -pos_x]
    panel_table <- gtable_add_cols(panel_table, sizes, pos_x + nudge)
  }
  
  for(i in seq_len(n_levels)) {
    if (!merge[i]) {
      panel_table <- gtable_add_grob(
        panel_table, splitstrip[[i]],
        t = pos_y + switch(orient, x = i + nudge, y = 0),
        l = pos_x + switch(orient, x = 0, y = i + nudge),
        z = 2, clip = "on",
        name = paste0("strip-", orient, "-", seq_along(splitstrip[[i]]))
      )
    } else {
      j <- as.numeric(as.factor(vars[,i]))
      ends <- cumsum(rle(j)$lengths)
      starts <- c(1, which(diff(j) != 0) + 1)
      panel_table <- gtable_add_grob(
        panel_table, splitstrip[[i]][starts],
        t = switch(orient, x = pos_y + i + nudge, y = pos_y[starts]),
        b = switch(orient, x = pos_y + i + nudge, y = pos_y[ends]),
        l = switch(orient, x = pos_x[starts], y = pos_x + i + nudge),
        r = switch(orient, x = pos_x[ends],   y = pos_x + i + nudge),
        z = 2, clip = "on",
        name = paste0("strip-", orient, "-", seq_along(splitstrip[[i]][starts]))
      )
      
      if(params$nest_line && any(starts != ends)) {
        insert_here <- which(starts != ends)
        indicator <- linesGrob(
          x = switch(orient,
                     x = unit(c(0, 1), "npc") + c(1, -1) * params$resect,
                     y = if (switch) c(1, 1) else c(0, 0)),
          y = switch(orient,
                     x = if (switch) c(1, 1) else c(0, 0),
                     y = unit(c(0, 1), "npc") + c(1, -1) * params$resect),
          gp = grid::gpar(col = theme$line$colour,
                          lty = theme$line$linetype,
                          lwd = theme$line$size * .pt,
                          lineend = theme$line$lineend))
        panel_table <- gtable_add_grob(
          panel_table, lapply(seq_along(insert_here), function(x) indicator),
          t = switch(orient, x = pos_y + i + nudge,
                     y = pos_y[starts[insert_here]]),
          b = switch(orient, x = pos_y + i + nudge,
                     y = pos_y[ends[insert_here]]),
          l = switch(orient, x = pos_x[starts[insert_here]],
                     y = pos_x + i + nudge),
          r = switch(orient, x = pos_x[ends[insert_here]],
                     y = pos_x + i + nudge),
          z = 3, clip = "on",
          name = "nesting-indicator"
        )
      }
    }
  }
  panel_table
}

